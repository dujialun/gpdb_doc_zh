<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="ki180869">启用高可用特性</title>
  <shortdesc>可以为Greenplum数据库的每个系统组件设置一个热备以确保系统高可用。</shortdesc>
  <body>
    <p>本章描述Greenplum数据库的高可用特性及恢复一个Master或Segment实例的过程。</p>
    <p>有关用来启用高可用性的工具的信息，请见<i>Greenplum Database Utility Guide</i>. </p>
  </body>
  <topic id="topic2" xml:lang="en">
    <title id="ki155204">Greenplum数据库高可用性概述</title>
    <body>
      <p>Greenplum数据库的服役时间和高可用性可以通过下列手段实现：</p>
      <ul>
        <li id="ki155212">
          <xref href="#topic3" type="topic" format="dita"/>
        </li>
        <li id="ki155216">
          <xref href="#topic4" type="topic" format="dita"/>
        </li>
        <li id="ki155220">
          <xref href="#topic5" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic3" xml:lang="en">
      <title id="ki155227">Segment镜像概述</title>
      <body>
        <p>当Greenplum数据库高可用性被启用时，有两种类型的Segment：<i>主</i>Segment和<i>镜像</i>Segment。
          每个主Segment都有一个对应的镜像Segment。主Segment从Master接收请求来对该Segment的数据库做更改并且
          接着把那些更改复制到对应的镜像。如果主Segment变成不可用，数据库请求会被故障转移到镜像Segment。</p>
        <p>Segment镜像采用了一种物理文件复制方案&#8212;主Segment上的数据文件I/O会被复制到镜像Segment，这样
          镜像的文件与主Segment的文件一模一样。Greenplum数据库中的数据被表示为<i>元组</i>，它们被打包成<i>块</i>。
          数据库表被存储在由一个或者更多块组成的磁盘文件中。对于元组的一个更改会改变其所在的块，该块接着会被写入
          到主Segment上的磁盘并且被通过网络复制到镜像Segment。镜像会在其文件副本中更新相应的块。</p>
        <p>对于堆表，块被保存在一个内存中的缓冲内，直到为了给新更改的块腾空间而将它们排出。这允许系统多次在内存中
          读写一个块而不需要执行昂贵的磁盘I/O。当块被从缓冲中排出时，它会被写入到磁盘并且复制到镜像中。当块被保存
          在缓冲中时，主Segment和镜像Segment有该块的不同映像。不过，数据库仍然是一致的，因为事务日志已经被复制。
          如果一个镜像接替了失效的主Segment，其日志中的事务会被应用到数据库表上。</p>
        <p>其他数据库对象&#8212;例如文件空间，它是内部由目录表示的表空间&#8212;也使用文件复制来以同步的方式执行
          多种文件操作。</p>
        <p>追加优化表不使用缓冲机制。对追加优化表块的更改会被立刻复制到镜像。典型地，文件写操作是异步的，而打开、
          创建和同步文件是“同步复制的”，这意味着主Segment会阻塞直到它收到来自镜像Segment的确认。</p>
        <p>为了配置镜像，Greenplum数据库系统必须拥有足够的节点来保证主Segment和它的镜像Segment位于不同的主机。
          在数据库操作过程中，仅有主Segment是活动的。</p>
        <fig id="ki169754">
          <title>Greenplum数据库中的Segment数据镜像</title>
          <image href="../../graphics/mirrorsegs.png" placement="break" width="485px" height="135px"
          />
        </fig>
        <p>如果主Segment失效，文件复制进程会停止并且镜像Segment自动地开始作为活动的Segment实例。当前活动的镜像
          Segment的系统状态会变成<i>Change Tracking</i>，这表示在主Segment不可用期间由该镜像维护系统表以及所
          有被更新块的改变日志。当失效的主Segment被修复并且准备好重新回到线上后，管理员可以发起一次恢复处理并且
          系统进入到<i>Resynchronization</i>状态。恢复处理会将记录下来的更改应用到已被修复的主Segment。当恢复
          处理完成后，系统状态会变成<i>Synchronized</i>。</p>
        <p>在主Segment状态为活动时，如果镜像Segment失效或者变成不可访问，主Segment的系统状态会变成
          <i>Change Tracking</i>，并且它会跟踪更改，当镜像被恢复时将更改应用到镜像Segment。</p>
      </body>
    </topic>
    <topic id="topic4" xml:lang="en">
      <title id="ki155249">Master镜像概述</title>
      <body>
        <p>可以在单独的主机或者同一台主机上部署Master实例的一个备份或者镜像。当主Master变得无法使用时，备份
          Master或者后备Master会作为一个温备提供服务。可在主Master在线时从中创建一个后备Master。</p>
        <p>在取一个主Master实例的事务快照时，主Master会继续为用户提供服务。在取事务快照以及在后备Master上部署
          事务快照时，对主Master的更改也会被记录。在该快照被部署在后备Master上之后，那些更新会被部署以同步后备
          Master和主Master。</p>
        <p>一旦主Master和后备Master被同步好，后备Master会通过<codeph>walsender</codeph>和
          <codeph>walreceiver</codeph>复制进程保持与主Master的同步。<codeph>walreceiver</codeph>是后备
          Master的进程。<codeph>walsender</codeph>进程是主Master进程。这两个进程使用基于预写式日志（WAL）
          的流复制来保持主Master和后备Master同步。</p>
        <p>由于Master不保存用户数据，只有系统目录表被在主Master和后备Master之间同步。当这些表被更新时，更改会
          被自动地复制到后备Master来让它保持与主Master的同步。</p>
        <fig id="ki155262">
          <title>Greenplum数据库中的Master镜像</title>
          <image href="../../graphics/standby_master.jpg" placement="break" width="271px"
            height="165px"/>
        </fig>
        <p>如果主Master失效，复制进程会停止并且管理员可以激活后备Master。在激活后备Master的过程中，复制好的日志
          可以重构主Master在最后一个成功提交事务时的状态。被激活的后备Master接下来就像Greenplum数据库的Master
          一样工作，在后备Master初始化时指定的端口上接受连接。</p>
      </body>
    </topic>
    <topic id="topic5" xml:lang="en">
      <title id="ki159645">故障检测与恢复概述</title>
      <body>
        <p>Greenplum数据库服务器名为<codeph>ftsprobe</codeph>的（<codeph>postgres</codeph>）子进程处理故障检测。
          <codeph>ftsprobe</codeph>会监控Greenplum数据库阵列，它连接并且扫描所有的Segment，并且数据库会按照配置的
          间隔进行这种处理。</p>
        <p>如果<codeph>ftsprobe</codeph>无法连接到一个Segment，它会在Greenplum数据库系统目录中标记该Segment为"down"。
          该Segment会保持无法操作的状态直到管理员发起恢复处理。</p>
        <p>如果启用了镜像，在主副本不可用时，Greenplum数据库会自动故障转移到镜像副本。
          由于所有的数据在余下的活动Segment上可用，如果Segment实例或者主机失效，系统也是可操作的。</p>
        <p>要恢复失效的Segment，管理员需要运行<codeph>gprecoverseg</codeph>恢复工具。这个工具定位失效的Segment、
          验证它们是否有效并且与当前活动的Segment比较事务状态来确定该Segment离线期间所作的更改。
          <codeph>gprecoverseg</codeph>会与活动的Segment同步发生改变的数据库文件并且重新让Segment上线。
          管理员可以在Greenplum数据库在线且运行时执行恢复。</p>
        <p>如果禁用了镜像，当一个Segment实例失效时，系统会自动关闭。在操作能继续之前，管理员必须手工恢复所有的失效Segment。</p>
      </body>
    </topic>
  </topic>
  <topic id="topic6" xml:lang="en">
    <title id="ki155342">在Greenplum数据库中启用镜像</title>
    <body>
      <p>可以在建立Greenplum数据库系统时使用<codeph>gpinitsystem</codeph>配置系统使用镜像，或者之后用<codeph>gpaddmirrors</codeph>
        以及<codeph>gpinitstandby</codeph>启用镜像。这个主题假定现有系统初始化时没有镜像，现在要向其中加入镜像。</p>
      <p>可以启用以下镜像内容：</p>
      <ul>
        <li id="ki155350">
          <xref href="#topic7" type="topic" format="dita"/>
        </li>
        <li id="ki155354">
          <xref href="#topic8" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic7" xml:lang="en">
      <title id="ki155357">启用Segment镜像</title>
      <body>
        <p>镜像Segment允许数据库查询在主Segment不可用时故障转移到备用Segment。为了配置镜像，Greenplum数据库
          系统必须具有足够的节点以保证镜像Segment和对应的主Segment不在同一台主机上。默认情况下，镜像会被配置在
          主Segment所在的主机阵列上。也可以为镜像Segment选择一组完全不同的主机，这样它们就不会分享任何主
          Segment的机器。</p>
        <note type="important">在在线数据复制处理期间，Greenplum数据库应该处于一种静止状态，不应运行负载和
          其他查询。</note>
        <section id="ki169450">
          <title>要增加Segment镜像到一个现有系统（和主Segment相同的主机阵列）</title>
          <ol>
            <li id="ki156981">在所有的Segment主机上为镜像数据分配数据存储区域。数据存储区域必须与主Segment
              的文件系统位置不同。</li>
            <li id="ki156983">使用<codeph>gpssh-exkeys</codeph>确保Segment主机能通过SSH和SCP免密码连接
              到彼此。</li>
            <li id="ki156993">运行<codeph>gpaddmirrors</codeph>工具在Greenplum数据库系统中启用镜像。
              例如，在主Segment端口号基础上加10000来计算得到镜像Segment的端口号：
              <codeblock>$ gpaddmirrors -p 10000</codeblock>
              <p>其中<codeph>-p</codeph>指定要加在主Segment端口号上的数字。使用默认的组镜像配置来增加镜像。
               </p></li>
          </ol>
        </section>
        <section>
          <title>要增加Segment镜像到一个现有系统（和主Segment不同的主机阵列）</title>
          <ol>
            <li id="ki155416">确保在所有主机上都安装有Greenplum数据库软件。详细的安装指导请见<i>Greenplum Database Installation Guide</i>。</li>
            <li id="ki161799">在所有的Segment主机上为镜像数据分配数据存储区域。</li>
            <li id="ki160816">使用<codeph>gpssh-exkeys</codeph>确保Segment主机能通过SSH和SCP免密码连接到彼此。</li>
            <li id="ki155422">创建一个配置文件，其中列出要在其上创建镜像的主机名称、端口号和数据目录。要创建
              一个示例配置文件作为起点，可运行：
              <codeblock>$ gpaddmirrors -o <i>filename</i></codeblock>
              <p>镜像配置文件的格式为：</p>
                <codeblock>filespaceOrder=[<i>filespace1_fsname</i>[:<i>filespace2_fsname</i>:...] 
<i>mirror</i>[<i>content</i>]=<i>content</i>:<i>address</i>:<i>port</i>:<i>mir_replication_port</i>:
<i>pri_replication_port</i>:<i>fselocation</i>[:<i>fselocation</i>:...]</codeblock>
              <p>例如这是一个配置文件，其中有两个Segment主机，每个主机上有两个Segment，并且除了默认的
                <i>pg_system</i>文件空间之外不配置额外的文件空间：</p>
              <codeblock>filespaceOrder=
mirror0=0:sdw1:sdw1-1:52001:53001:54001:/gpdata/mir1/gp0
mirror1=1:sdw1:sdw1-2:52002:53002:54002:/gpdata/mir1/gp1
mirror2=2:sdw2:sdw2-1:52001:53001:54001:/gpdata/mir1/gp2
mirror3=3:sdw2:sdw2-2:52002:53002:54002:/gpdata/mir1/gp3
</codeblock></li>
            <li id="ki155430">运行<codeph>gpaddmirrors</codeph>工具在Greenplum数据库系统中启用镜像：
              <codeblock>$ gpaddmirrors -i <i>mirror_config_file</i></codeblock>
              <p>其中<codeph>-i</codeph>指定所创建的镜像配置文件。</p></li>
          </ol>
        </section>
      </body>
    </topic>
    <topic id="topic8" xml:lang="en">
      <title id="ki155443">启用Master镜像</title>
      <body>
        <p>可以用<codeph>gpinitsystem</codeph>来配置一个带有后备Master的新Greenplum数据库系统，
          或者以后用<codeph>gpinitstandby</codeph>来启用后备Master。这个主题假定现有系统初始化时没有
          后备Master，现在要向其中加入一个后备Master。</p>
        <section id="ki160203">
          <title>要向一个现有系统增加一个后备Master</title>
          <ol>
            <li id="ki160206">确保后备Master主机已经被安装且配置好Greenplum数据库：<codeph>gpadmin</codeph>
              系统用户已创建、Greenplum数据库二进制文件已安装、环境变量已设置、SSH密钥已交换并且数据目录已创建。
              详细信息请见<i>Greenplum Database Installation Guide</i>。</li>
            <li id="ki155475">在当前活动的<i>primary</i>Master主机上运行<codeph>gpinitstandby</codeph>工具向Greenplum
              数据库系统增加一个后备Master主机。例如：
              <codeblock>$ gpinitstandby -s smdw</codeblock>
              <p>这里<codeph>-s</codeph>指定后备Master主机的名称。</p></li>
            <li id="ki155485">要把操作切换到后备Master上，请见<xref href="#topic16"
                type="topic" format="dita"/>.</li>
          </ol>
          <title>检查Master镜像进程状态（可选）</title>
          <p>可以通过查看Greenplum数据库系统视图pg_stat_replication来展示状态信息。该视图列出Greenplum数据库主节点镜像
            的<codeph>walsender</codeph>进程信息。例如，这个命令显示 <codeph>walsender</codeph>进程的进程ID和状态：</p>
          <codeblock>$ psql dbname -c 'SELECT procpid, state FROM pg_stat_replication;'</codeblock>
          <p>有关<codeph>pg_stat_replication</codeph>系统视图的信息请见<i>Greenplum Database Reference Guide</i>。</p>
        </section>
      </body>
    </topic>
  </topic>
  <topic id="topic9" xml:lang="en">
    <title id="ki155550">检测失效的Segment</title>
    <body>
      <p>如果启用了镜像，Greenplum数据库会在主Segment宕机后自动故障转移到一个镜像Segment上。镜像Segment承担
        主Segment的角色和职能，故障主Segment变成镜像。当故障出现时，正在进行中的事务会回滚并重启。重启完成后，
        该事务会在新的主Segment上运行。</p>
      <p>为恢复Greenplum数据库集群的全冗余和负载均衡状态，管理员需要修复故障Segment节点并重置主Segment和
        镜像Segment角色以保证二者都处于最佳的角色位置。</p>
      <p>如果整个Greenplum数据库系统由于一个Segment失效（例如，如果没有启用镜像或者没有足够的Segment在线
        以访问全部用户数据）而变得无法运转，用户在尝试连接到数据库时会看到错误。返回给客户端程序的错误可能表明
        失效。例如：</p>
      <codeblock>ERROR: All segment databases are unavailable</codeblock>
    </body>
    <topic id="topic11" xml:lang="en">
      <title>检测失效Segment</title>
      <body>
        <p>启用镜像的情况下，系统允许存在故障Segment并且不影响数据库服务正常运行。可以通过<codeph>gpstate</codeph>
          工具查看整个数据库系统状态。<codeph>gpstate</codeph>可以展示整个数据库系统中包括主Segment、镜像Segment、
          Master和备用Master在内的每一个单独系统组件的状态。</p>
        <section id="ki155580">
          <title>如何检测故障Segment</title>
          <ol>
            <li id="ki155584">在Master上，用<codeph>-e</codeph>选项运行<codeph>gpstate</codeph>工具显示有
              错误情况的Segment：
                <codeblock>$ gpstate -e</codeblock>
              <p><i>Change Tracking</i>模式下的Segment表示对应的镜像Segment已经宕机。当一个Segment不是其
                <i>首选角色</i>时，该Segment没有按照系统初始化时指定给它的角色操作。这意味着系统可能处于一种不平衡
                的状态，因为一些Segment主机上的活动Segment比系统处于最好性能时多。</p>
              <p>修复这种问题的方法请见<xref href="#topic14" type="topic"
                  format="dita"/>。</p></li>
            <li id="ki165350">要得到一个失效Segment的详细信息，可检查<i>gp_segment_configuration</i>catalog表。
              例如：
              <codeblock>$ psql -c "SELECT * FROM gp_segment_configuration WHERE status='d';"</codeblock></li>
            <li id="ki162539">对于失效的Segment实例，要关注其主机、端口、首选角色和数据目录。这些信息将会有助于确定
              要排除故障的主机和Segment实例。</li>
            <li id="ki155591">要显示有关镜像Segment实例的信息，可运行：
              <codeblock>$ gpstate -m</codeblock></li>
          </ol>
        </section>
      </body>
    </topic>
    <topic id="topic12" xml:lang="en">
      <title id="ki155597">检查日志文件</title>
      <body>
        <p>日志文件可以提供信息来帮助判断一个错误的成因。每个Master和Segment实例都在其数据目录的
          <codeph>pg_log</codeph>中有它们自己的日志文件。Master的日志文件包含了大部分信息，应该总是首先检查它。</p>
        <p>使用<codeph>gplogfilter</codeph>工具来检查Greenplum数据库的日志文件以获得额外的信息。要检查Segment
          的日志文件，使用<codeph>gpssh</codeph>在Segment主机上运行<codeph>gplogfilter</codeph>。</p>
        <section id="ki170080">
          <title>如何检查日志文件</title>
          <ol>
            <li id="ki168755">对于<codeph>WARNING</codeph>、<codeph>ERROR</codeph>、<codeph>FATAL</codeph>或
              <codeph>PANIC</codeph>日志级别的消息，使用<codeph>gplogfilter</codeph>检查Master的日志文件：
              <codeblock>$ gplogfilter -t</codeblock></li>
            <li id="ki166372">对于每个Segment实例上的<codeph>WARNING</codeph>、<codeph>ERROR</codeph>、
              <codeph>FATAL</codeph>或<codeph>PANIC</codeph>日志级别的消息，使用gpssh检查。例如：
              <codeblock>$ gpssh -f seg_hosts_file -e 'source 
/usr/local/greenplum-db/greenplum_path.sh ; gplogfilter -t 
/data1/primary/*/pg_log/gpdb*.log' &gt; seglog.out
</codeblock></li>
          </ol>
        </section>
      </body>
    </topic>
  </topic>
  <topic id="topic13" xml:lang="en">
    <title id="ki155618">恢复故障Segment</title>
    <body>
      <p>如果Master无法连接到一个Segment实例，它会在Greenplum数据库的系统目录中把该Segment标记为“down”。
        该Segment实例会保持离线状态直到管理员采取步骤让它重新回到线上。恢复一个失效Segment实例或者主机的
        处理取决于失效原因以及是否启用了镜像。一个Segment实例的故障原因多种多样：</p>
      <ul>
        <li id="ki155624">Segment主机不可用，例如由于网络或者硬件失效。</li>
        <li id="ki155625">Segment实例没有运行，例如没有postgres数据监听器进程。</li>
        <li id="ki155626">Segment实例的数据目录损坏或者丢失，例如数据不可访问、文件系统损坏或者磁盘失效。</li>
      </ul>
      <p><xref href="#topic13/ki155628" type="fig" format="dita"/> 展示了前述失效场景的高层排查步骤。</p>
      <fig id="ki155628">
        <title>Segment失效故障排查矩阵</title>
        <image href="../../graphics/recovermatrix.png" placement="break" width="460" height="430px"
          id="image_cdg_nfp_34"/>
      </fig>
    </body>
    <topic id="topic14" xml:lang="en">
      <title>从Segment故障中恢复</title>
      <body>
        <p>Segment主机故障通常会导致多个Segment故障：在该主机上的所有主Segment或者镜像Segment都被标记为“down”
          并且不可操作。如果没有启用镜像并且一个Segment宕掉，系统会自动变成不可操作。</p>
        <section id="ki155642">
          <title>在启用了镜像的情况下恢复</title>
          <ol>
            <li id="ki155643">确保可以从Master主机连接到该Segment主机。例如：
              <codeblock>$ ping <i>failed_seg_host_address</i></codeblock></li>
            <li id="ki155645">排查解决妨碍Master主机连接到Segment主机的问题。例如，主机可能需要被重启或者替换。</li>
            <li id="ki155646">在主机上线并且能连接到它后，从Master主机运行<codeph>gprecoverseg</codeph>工具
              来重新激活故障的Segment实例。例如：
              <codeblock>$ gprecoverseg</codeblock></li>
            <li id="ki158500">恢复过程会启动失效的Segment并且确定需要同步的已更改文件。该过程可能会花一些时间，
              请等待该过程结束。在此过程中，数据库的写活动会被禁止。</li>
            <li id="ki164382">在<codeph>gprecoverseg</codeph>完成后，系统会进入到<i>Resynchronizing</i>
              模式并且开始复制更改过的文件。这个过程在后台运行，而系统处于在线状态并且能够接受数据库请求。</li>
            <li id="ki158504">当重新同步过程完成时，系统状态是<i>Synchronized</i>。运行<codeph>gpstate</codeph>
              工具来验证重新同步进程的状态：
              <codeblock>$ gpstate -m</codeblock></li>
          </ol>
          <title id="ki155666">要让所有Segment返回到它们的首选角色</title>
          <p>当一个主Segment宕掉后，镜像会激活并且成为主Segment。在运行<codeph>gprecoverseg</codeph>之后，
            当前活动的Segment仍是主Segment而失效的Segment变成镜像Segment。这些Segment实例并没有回到在系统
            初始化时为它们指定的首选角色。这意味着，如果Segment主机上的活动Segment数量超过了让系统性能最优的
            数量，系统可能处于一种潜在地非平衡状态。要检查非平衡的Segment并且重新平衡系统，运行：</p>
          <codeblock>$ gpstate -e</codeblock>
          <p>所有Segment都必须在线并且被完全同步以重新平衡系统。在重新平衡过程中，数据库会话保持连接，但正在
            进行的查询会被取消并且回滚。</p>
          <ol>
            <li id="ki165540">运行<codeph>gpstate -m</codeph>来确保所有镜像都是<i>Synchronized</i>。
              <codeblock>$ gpstate -m</codeblock></li>
            <li id="ki165577">如果有任何镜像处于<i>Resynchronizing</i>模式，等它们完成。</li>
            <li id="ki165591">用-r选项运行gprecoverseg，让Segment回到它们的首选角色。
              <codeblock>$ gprecoverseg -r</codeblock></li>
            <li id="ki166668">在重新平衡之后，运行<codeph>gpstate -e</codeph>来确认所有的Segment都处于
              它们的首选角色。
              <codeblock>$ gpstate -e</codeblock></li>
          </ol>
          <title>要从双重故障中恢复</title>
          <p>在双重故障中，主Segment和它的镜像都宕掉。如果在不同的Segment主机上同时发生硬件失效，就有可能发生
            这种情况。如果发生双重故障，Greenplum数据库会变得不可用。从一次双重故障中恢复的步骤如下：</p>
          <ol>
            <li id="ki165670">重启Greenplum数据库：
              <codeblock>$ gpstop -r</codeblock></li>
            <li id="ki165671">在系统重启后，运行<codeph>gprecoverseg</codeph>：
              <codeblock>$ gprecoverseg</codeblock></li>
            <li id="ki165709">在<codeph>gprecoverseg</codeph>完成后，使用<codeph>gpstate</codeph>检查
              镜像的状态：
              <codeblock>$ gpstate -m</codeblock></li>
            <li id="ki165730">如果仍有Segment处于Change Tracking模式，运行一次完整复制恢复：
              <codeblock>$ gprecoverseg -F</codeblock></li>
          </ol>
          <title>在没有启用镜像的情况下恢复</title>
          <ol>
            <li id="ki155667">确保能够从Master主机连接到该Segment主机。例如：
              <codeblock>$ ping <i>failed_seg_host_address
</i></codeblock></li>
            <li id="ki155669">排查解决妨碍Master主机连接到Segment主机的问题。例如，主机可能需要被重新启动。</li>
            <li id="ki155670">在主机在线之后，验证能够连接到它并且重启Greenplum数据库。例如：
              <codeblock>$ gpstop -r</codeblock></li>
            <li id="ki155681">运行<codeph>gpstate</codeph>工具验证所有的Segment实例都在线：
              <codeblock>$ gpstate</codeblock></li>
          </ol>
          <p>如果无法恢复一台Segment主机并且损失了一个或者多个Segment，可以从备份文件中重新创建Greenplum
            数据库系统。请见<xref href="backup.xml#topic1"
              type="topic" format="dita"/>。</p>
        </section>
      </body>
      <topic id="topic15" xml:lang="en">
        <title>当一台Segment主机不可恢复时</title>
        <body>
          <p>如果一台主机是不可操作的（例如由于硬件失效导致），就需要把那些Segment恢复到备用的硬件资源上。
            如果启用了镜像，可以使用<codeph>gprecoverseg</codeph>从Segment的镜像把它恢复到另一台
            主机上。例如：</p>
          <codeblock>$ gprecoverseg -i <i>recover_config_file</i></codeblock>
          <p>其中<codeph><i>recover_config_file</i></codeph>的格式是：</p>
          <codeblock>filespaceOrder=[<i>filespace1_name</i>[:<i>filespace2_name</i>:...]<i>failed_host_address</i>:
<i>port</i>:<i>fselocation</i> [<i>recovery_host_address</i>:<i>port</i>:<i>replication_port</i>:<i>fselocation</i>
[:<i>fselocation</i>:...]]</codeblock>
          <p>例如，要恢复到不同于失效主机的另一主机上且该没有额外的文件空间配置，（除默认的<i>pg_system</i>文件空间外）：</p>
          <codeblock>filespaceOrder=sdw5-2:50002:/gpdata/gpseg2 sdw9-2:50002:53002:/gpdata/gpseg2</codeblock>
          <p>The <i>gp_segment_configuration</i>和<i>pg_filespace_entry</i>系统表可以帮助确定当前的Segment配置，
            这样才能规划镜像恢复配置。例如，运行下面的查询：</p>
          <codeblock>=# SELECT dbid, content, hostname, address, port, 
   replication_port, fselocation as datadir 
   FROM gp_segment_configuration, pg_filespace_entry 
   WHERE dbid=fsedbid 
   ORDER BY dbid;</codeblock>
          <p>新恢复的Segment主机必须预装好Greenplum数据库软件并且按照现有Segment主机相同的方式配置。</p>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic16" xml:lang="en">
    <title id="ki155774">恢复故障的Master</title>
    <body>
      <p>如果主Master故障，日志复制会停止。使用<codeph>gpactivatestandby</codeph>来激活后备Master。
        在激活后备Master过程中，Greenplum数据库会重构Master主机为最后一次成功提交事务时的状态。</p>
      <section id="ki181117">
        <title>激活后备Master</title>
        <ol>
          <li id="ki155784">确保为系统已经配置了一个后备Master主机。见<xref
              href="#topic8" type="topic" format="dita"/>.</li>
          <li id="ki155791">从正在激活的后备Master主机运行<codeph>gpactivatestandby</codeph>工具。例如：
            <codeblock>$ gpactivatestandby -d /data/master/gpseg-1</codeblock>
            <p>其中<codeph>-d</codeph>指定正在激活的Master主机的数据目录。</p>
            <p>在激活后备之后，它会变成Greenplum数据库阵列中的<i>active</i>或者<i>primary</i>Master。</p></li>
          <li id="ki155816">在该工具结束后，运行<codeph>gpstate</codeph>来检查状态：
            <codeblock>$ gpstate -f</codeblock>
            <p>最新被激活的Master的状态应该是<i>Active</i>。如果配置了一个新的后备主机，它的状态是<i>Passive</i>。
              在没有配置后备Master时，该命令会显示<codeph>-No entries found</codeph>，该消息表示没有配置
              后备Master实例。</p></li>
          <li id="ki169625">在切换到最新的活动Master主机后，在其上运行<codeph>ANALYZE</codeph>。例如：
              <codeblock>$ psql <codeph>dbname</codeph> -c 'ANALYZE;'</codeblock></li>
          <li id="ki155823">可选：如果运行<codeph>gpactivatestandby</codeph>工具时没有指定一个新的后备主机，
            之后可使用<codeph>gpinitstandby</codeph>配置一个新的后备Master。应在活动Master主机上运行
            <codeph>gpinitstandby</codeph>例如：
            <codeblock>$ gpinitstandby -s <i>new_standby_master_hostname</i></codeblock></li>
        </ol>
      </section>
    </body>
    <topic id="topic17" xml:lang="en">
      <title>在恢复后还原Master镜像</title>
      <body>
        <p>在激活一台后备Master进行恢复后，该后备Master会成为主Master。如果后备Master具有和原始Master主机
          相同的能力和可靠性，可以继续把该实例当作主Master。</p>
        <p>必须初始化一个新的后备Master继续提供Master的镜像，除非在激活前一个后备Master时已经这样做了。
          在活动的Master主机上运行<codeph>gpinitstandby</codeph>来配置一个新的后备Master。</p>
        <p>可以在原来的主机上恢复主Master和后备Master。这个过程会交换主Master主机和后备Master主机的角色，
          只有强烈希望在恢复之前的相同主机上运行Master实例时才执行这样的操作。</p>
        <section id="ki160986">
          <title>在原来的主机上恢复Master和后备Master（可选）</title>
          <ol>
            <li id="ki160936">确认原来的Master主机有可靠的运行条件，确保以前的失效原因已被修复。</li>
            <li>在原来的Master主机上，移动或者移除数据目录<codeph>gpseg-1</codeph>。这个例子把该目录
              移动到<codeph>backup_gpseg-1</codeph>：
                <codeblock>$ mv /data/master/gpseg-1 /data/master/backup_gpseg-1</codeblock>
              <p>一旦后备被成功地配置，就可以移除备份目录。</p></li>
            <li id="ki160940">在原来的Master主机上初始化一个后备Master。例如，从当前的Master主机
              （smdw）运行这个命令：
              <codeblock>$ gpinitstandby -s mdw</codeblock></li>
            <li>在初始化完成后，检查后备Master（mdw）的状态，用<codeph>-f</codeph>选项运行
              <codeph>gpstate</codeph>来检查状态：
              <codeblock>$ gpstate -f</codeblock>
              <p>状态应该是<i>In Synch</i>。</p></li>
            <li>在后备Master上停止Greenplum数据库的Master实例。例如：
              <codeblock>$ gpstop -m</codeblock></li>
            <li id="ki160961">从原始的Master主机mdw运行<codeph>gpactivatestandby</codeph>工具，
              该主机当前是一个后备Master。例如：
              <codeblock>$ gpactivatestandby -d $MASTER_DATA_DIRECTORY</codeblock>
              <p>其中<codeph>-d</codeph>选项指定正在激活的主机的数据目录。</p></li>
            <li id="ki165618">在该工具完成后，运行<codeph>gpstate</codeph>来检查状态：
              <codeblock>$ gpstate -f </codeblock>
              <p>验证原来的主Master状态为<i>Active</i>。当没有配置一个后备Master时，
                该命令显示<codeph>-No entries found</codeph>并且该消息表示没有配置一个后备Master实例。</p></li>
            <li>在后备Master主机上，移动或者移除数据目录<codeph>gpseg-1</codeph>。这个例子移动该目录：
                <codeblock>$ mv /data/master/gpseg-1 /data/master/backup_gpseg-1</codeblock>
              <p>一旦成功地配置好后备，就可以移除备份目录。</p></li>
            <li id="ki165609">在原来的Master主机运行主Greenplum数据库Master之后，可以在原来的后备Master
              主机上初始化一个后备Master。例如：
              <codeblock>$ gpinitstandby -s smdw</codeblock></li>
          </ol>
          <title>检查主Master镜像进程状态（可选）</title>
          <p>Greenplum数据库系统视图pg_stat_replication可以显示相关的信息。该视图列出用于Greenplum数据库
            Master镜像的<codeph>walsender</codeph>进程的信息。例如，这个命令显示<codeph>walsender</codeph>
            进程的进程ID和状态：</p>
          <codeblock>$ psql dbname -c 'SELECT procpid, state FROM pg_stat_replication;'</codeblock>
        </section>
      </body>
    </topic>
  </topic>
</topic>
