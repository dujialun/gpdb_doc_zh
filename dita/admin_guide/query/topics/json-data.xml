<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="ih135496">使用JSON数据</title>
  <shortdesc>Greenplum数据库支持<codeph>json</codeph>和<codeph>jsonb</codeph>数据类型来存储JSON (JavaScript Object Notation)数据。</shortdesc>
  <body>
    <p>Greenplum数据库按照文档<xref
        href="https://tools.ietf.org/html/rfc7159" format="html" scope="external">RFC 7159</xref>
      支持JSON,并且根据JSON规则强制数据有效性。也有一些用于<codeph>json</codeph> and <codeph>jsonb</codeph>数据类型的JSON相关的函数和操作符。参见<xref href="#topic_gn4_x3w_mq" format="dita"/>. </p>
    <p>这一节包含下列主题：<ul id="ul_sjd_hsr_fz">
        <li><xref href="#topic_upc_tcs_fz" format="dita"/></li>
        <li><xref href="#topic_isn_ltw_mq" format="dita"/></li>
        <li><xref href="#topic_eyt_3tw_mq" format="dita"/></li>
        <li><xref href="#topic_isx_2tw_mq" format="dita"/></li>
        <li><xref href="#topic_aqt_1tw_mq" format="dita"/></li>
        <li><xref href="#topic_gn4_x3w_mq" format="dita"/></li>
      </ul></p>
  </body>
  <topic id="topic_upc_tcs_fz">
    <title>关于JSON数据</title>
    <body>
      <p>Greenplum数据库支持两种JSON数据类型: <codeph>json</codeph> and
          <codeph>jsonb</codeph>. 他们输入值基本一致，主要区别之一是效率。 <ul id="ul_qv2_zrw_mq">
          <li>The <codeph>json</codeph>数据类型存储输入副本. 这要求JSON处理函数每次执行时处理<codeph>json</codeph> 数据。<codeph>json</codeph>数据类型不会修改输入文本。<ul
              id="ul_yrn_njf_pfb">
              <li>记号之间没有语义意义的空格被保留，JSON对象内的键的顺序也被保留。</li>
              <li>即便JSON对象含有重复键，所有的键/值对也会被保留。对于重复键，JSON处理函数把其中的最后一个值当作有效值。</li>
            </ul></li>
          <li> <codeph>jsonb</codeph>数据类型存储输入文本的二进制格式。输入数据的转换开销使jsonb稍慢于
              <codeph>json</codeph>数据类型. 但是, json处理函数明显更快，因为解析<codeph>jsonb</codeph>数据不是必须的。
              <codeph>jsonb</codeph>数据类型修改输入文本。<ul id="ul_bzp_hkf_pfb">
              <li>空格不保留</li>
              <li>对象内的键的顺序不保留</li>
              <li>重复键对象不保留，如果输入包含重复键，仅保留最后一个值。</li>
            </ul><p><codeph>jsonb</codeph>数据类型支持索引。参考 <xref
                href="#topic_aqt_1tw_mq" format="dita"/>.</p></li>
        </ul></p>
      <p>一般来说，JSON数据应该存储为<codeph>jsonb</codeph>数据类型，除非特殊需要，例如关于对象键顺序的遗留假设。</p>
      <section>
        <title>关于JSON数据中的Unicode字符</title>
        <p>The <xref href="http://rfc7159.net/rfc7159" format="html" scope="external">RFC
            7159</xref>文档允许JSON字符串包含表示为\uXXXX的<codeph>\u<varname>XXXX</varname></codeph>Unicode转义序列。不过, Greenplum对每一个数据库只允许一种字符集编码。
          除非数据库编码为UTF8，<codeph>json</codeph>类型不可能严格地符合JSON说明。尝试包括数据库编码中无法表示的字符将会失败。允许可在数据库编码中表示但不在UTF8中的字符。</p>
        <p>
          <ul id="ul_ejw_ppf_pfb">
            <li><codeph>json</codeph>数据类型的greenplum数据库输入函数允许unicode转义，而无论是什么数据库编码，只检查unicode转义的语法正确性（a <codeph>\u</codeph>后跟四个十六进制数字）。
              </li>
            <li><codeph>jsonb</codeph>数据类型的greenplum数据库输入函数更严格。它不允许非ASCII字符（<codeph>U+007F</codeph>以上的字符）使用Unicode转义，除非数据库编码是UTF8。它还拒绝<codeph>\u0000</codeph>，它不能在greenplum数据库<codeph>text</codeph>类型中表示，并且它要求使用unicode代理项对指定unicode基本多语言平面之外的字符是正确的。有效的Unicode转义符（除了<codeph>\u0000</codeph>）转换为等效的ASCII或UTF8字符进行存储；这包括将代理项对折叠为单个字符。
              </li>
          </ul>
        </p>
        <note> <xref href="#topic_gn4_x3w_mq" format="dita">JSON函数和运算符</xref>中描述的许多JSON处理函数将Unicode转义转换为常规字符。函数对数据库编码中无法表示的字符抛出错误。如果可能的话，应该避免将JSON中的Unicode转义与非UTF8数据库编码混合在一起。</note>
      </section>
      <section>
        <title>将JSON数据类型映射到Greenplum数据类型</title>
        <p>When converting JSON text input into <codeph>jsonb</codeph> data, the primitive data
          types described by RFC 7159 are effectively mapped onto native Greenplum Database data
          types, as shown in the following table.</p>
        <table id="table_spm_m3w_mq">
          <title>将JSON数据类型映射到Greenplum数据类型</title>
          <tgroup cols="3">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <colspec colnum="3" colname="col3"/>
            <thead>
              <row>
                <entry>JSON原始数据类型</entry>
                <entry>Greenplum数据库数据类型</entry>
                <entry>注意</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry><codeph>string</codeph>
                </entry>
                <entry><codeph>text</codeph>
                </entry>
                <entry>不允许使用<codeph>\u0000</codeph>。只有当数据库编码为utf8时，才允许使用非ASCII Unicode转义。</entry>
              </row>
              <row>
                <entry><codeph>number</codeph>
                </entry>
                <entry><codeph>numeric</codeph>
                </entry>
                <entry>不允许使用<codeph>NaN</codeph>和<codeph>infinity</codeph>值
         </entry>
              </row>
              <row>
                <entry><codeph>boolean</codeph>
                </entry>
                <entry><codeph>boolean</codeph>
                </entry>
                <entry>只接受小写的正误拼写</entry>
              </row>
              <row>
                <entry><codeph>null</codeph>
                </entry>
                <entry>(none)</entry>
                <entry>The JSON <codeph>null</codeph> 原始类型不同于<codeph>NULL</codeph>。</entry>
              </row><codeph>numeric</codeph>
            </tbody>
          </tgroup>
        </table>
        <p>对于有效的<codeph>jsonb</codeph> 数据的构成有一些次要的约束，这些约束既不适用于<codeph>json</codeph> 数据类型，也不适用于抽象的JSON，对应于基础数据类型所能表示的限制。值得注意的是，当将数据转换为<codeph>jsonb</codeph>数据类型时，超出Greenplum数据库<codeph>numeric</codeph>数据类型范围的数字将被拒绝，而<codeph>json/codeph>数据类型不会拒绝这些数字。
        </p>
        <p>RFC 7159允许这种实施定义的限制。然而，在实践中，这些问题可能会出现在其他实现中，因为通常将JSON原始类型 <codeph>number</codeph>表示为IEEE 754双精度浮点（RFC7159明确预测并允许）。
          </p>
        <p>当使用JSON作为与其他系统的交换格式时，请注意与Greenplum数据库最初存储的数据相比，数字精度可能会降低。</p>
        <p>另外，正如上表中所指出的，对于JSON原语类型的输入格式，存在一些小的限制，这些限制不适用于相应的Greenplum数据库数据类型。 .</p>
      </section>
    </body>
  </topic>
  <topic id="topic_isn_ltw_mq">
    <title>JSON输入和输出语法</title>
    <body>
      <p> <codeph>json</codeph>数据类型的输入和输出语法如RFC 7159中所述。</p>
      <p>下列都是合法的<codeph>json</codeph>表达式：</p>
      <codeblock>-- 简单标量/原始值
-- 原始值值可以是数字、带引号的字符串、true、false或者null SELECT '5'::json;

-- 零个或者更多个元素的数组（元素类型可以不同）
          SELECT '[1, 2, "foo", null]'::json;

-- 含有键/值对的对象
-- 注意对象的键必须总是带引号的字符串
SELECT '{"bar": "baz", "balance": 7.77, "active": false}'::json;

-- 数组和对象可以任意嵌套
SELECT '{"foo": [true, "bar"], "tags": {"a": 1, "b": null}}'::json;</codeblock>
      <p>如前所述，当输入JSON值，然后在不进行任何附加处理的情况下打印时，<codeph>json</codeph>数据类型输出的文本与输入的文本相同，而<codeph>jsonb</codeph>数据类型不保留语义上不重要的细节，如空白。例如，请注意这里的区别：</p>
      <codeblock>SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::json;
                      json                       
-------------------------------------------------
 {"bar": "baz", "balance": 7.77, "active":false}
(1 row)

SELECT '{"bar": "baz", "balance": 7.77, "active":false}'::jsonb;
                      jsonb                       
--------------------------------------------------
 {"bar": "baz", "active": false, "balance": 7.77}
(1 row)</codeblock>
      <p>值得注意的一个语义上不重要的细节是，对于<codeph>jsonb</codeph>数据类型，将根据基础数字类型的行为打印数字。在实践中，这意味着使用e符号输入的数字将不使用e符号打印，例如：
         </p>
      <codeblock>SELECT '{"reading": 1.230e-5}'::json, '{"reading": 1.230e-5}'::jsonb;
         json          |          jsonb          
-----------------------+-------------------------
 {"reading": 1.230e-5} | {"reading": 0.00001230}
(1 row)</codeblock>
      <p>然而, <codeph>jsonb</codeph>数据类型保留了尾随的小数零，如前一个示例中所示，即使这些小数零在语义上对于诸如相等性检查之类的是无关紧要的。</p>
    </body>
  </topic>
  <topic id="topic_eyt_3tw_mq">
    <title>设计JSON文档</title>
    <body>
      <p>将数据表示为JSON比传统关系数据模型要更灵活，在需求变化的环境中表现得尤其明显。在同一个应用中很可能两种方法会共存并且成为彼此的互补。不过，即便是对于要求最大灵活性的应用中，我们仍然推荐JSON有些许固定的结构。这种结构是非强制的（尽管可能会强制一些业务规则），但是如果有可预测的结构会让编写有效汇总表中一组“文档”（数据）的查询更容易。</p>
      <p>在表中存储时，JSON数据服从和其他任何数据类型一样的并发控制考虑。尽管存储大型文档格式可行的，但要记住任何更新都要求整个行上的一个行级锁。为了降低更新事务之间的锁竞争，请考虑限制JSON文档为一个可管理的尺寸。理想上，每个JSON文档应该表示业务规则规定的一个原子数据，并且不能进一步地被分解为更小的可以独立修改的数据。
    </p>
    </body>
  </topic>
  <topic id="topic_isx_2tw_mq">
    <title>jsonb容器与存在</title>
    <body>
      <p>测试容器是<codeph>jsonb</codeph>的一项重要功能。 <codeph>json</codeph>类型没有并行的设施集。容器测试一个<codeph>jsonb</codeph> 文档中是否包含了另一个<codeph>jsonb</codeph> 文档。这些例子返回true，除非另有标注：
    </p>
      <codeblock>--简单标量/原始数值仅包含相同的值：
SELECT '"foo"'::jsonb @> '"foo"'::jsonb;

-- 右边的数组包含在左边的数组中：
SELECT '[1, 2, 3]'::jsonb @> '[1, 3]'::jsonb;

--数组元素的顺序并不重要，因此这也是正确的：
SELECT '[1, 2, 3]'::jsonb @> '[3, 1]'::jsonb;

-- 重复的数组元素也不重要：
SELECT '[1, 2, 3]'::jsonb @> '[1, 2, 2]'::jsonb;

-- 右侧只有一对的对象包含在左侧的对象中:
SELECT '{"product": "Greenplum", "version": "6.0.0", "jsonb":true}'::jsonb @> '{"version":"6.0.0"}'::jsonb;

--右侧的数组被认为不包含在左侧的数组中，即使其中嵌套了类似的数组：
SELECT '[1, 2, [1, 3]]'::jsonb @> '[1, 3]'::jsonb;  -- yields false

--但是，通过一层嵌套，它包含：
SELECT '[1, 2, [1, 3]]'::jsonb @> '[[1, 3]]'::jsonb;

--同样，此处未报告遏制：
SELECT '{"foo": {"bar": "baz", "zig": "zag"}}'::jsonb @> '{"bar": "baz"}'::jsonb; -- yields false

-- 但是，通过一层嵌套，它包含：
SELECT '{"foo": {"bar": "baz", "zig": "zag"}}'::jsonb @> '{"foo": {"bar": "baz"}}'::jsonb;</codeblock>
      <p>一般原则是，所包含的对象必须在结构和数据内容方面与包含的对象匹配，可能是在从包含的对象中丢弃一些不匹配的数组元素或对象键/值对之后。
          对于容器，在进行容器匹配时，数组元素的顺序并不重要，重复的数组元素只被有效地考虑一次。
         </p>
      <p>作为结构必须匹配的一般原则的例外，数组可以包含原始值：</p>
      <codeblock>-- 此数组包含原始字符串值：:
SELECT '["foo", "bar"]'::jsonb @> '"bar"'::jsonb;

-- 这个异常不是相互的——这里报告了非包容：:
SELECT '"bar"'::jsonb @> '["bar"]'::jsonb;  -- yields false</codeblock>
      <p><codeph>jsonb</codeph> 还有一个<i>existence</i>操作符，它是容器主题的变体：它测试字符串（作为文本值给出）是否作为对象键或数组元素出现在<codeph>jsonb</codeph> 值的顶层。这些示例返回true，，除非另有标注：
       </p>
      <codeblock>-- 字符串作为数组元素存在：
SELECT '["foo", "bar", "baz"]'::jsonb ? 'bar';

-- 字符串作为对象键存在：
SELECT '{"foo": "bar"}'::jsonb ? 'foo';

-- 不考虑对象值：
SELECT '{"foo": "bar"}'::jsonb ? 'bar';  -- yields false

-- 与容器一样，存在必须在顶层匹配：
SELECT '{"foo": {"bar": "baz"}}'::jsonb ? 'bar'; -- yields false

-- 如果字符串与原始JSON字符串匹配，则认为该字符串存在：
SELECT '"foo"'::jsonb ? 'foo';</codeblock>
      <p>当涉及到许多键或元素时，JSON对象比数组更适合测试包含性或存在性，因为与数组不同，JSON对象在内部针对搜索进行了优化，不需要进行线性搜索。</p>
      <p>各种容器和存在操作符以及所有其他JSON操作符和函数都记录在JSON函数和操作符<xref href="#topic_gn4_x3w_mq" format="dita"/>中。</p>
      <p>因为JSON容器是嵌套的，所以适当的查询可以跳过子对象的显式选择。例如，假设我们有一个包含顶级对象的doc列，其中大多数对象包含子对象数组的标记字段。此查询查找包含<codeph>"term":"paris"</codeph>和<codeph>"term":"food"</codeph>的子对象出现的条目，同时忽略标记数组之外的任何此类键：
        </p>
      <codeblock>SELECT doc->'site_name' FROM websites
  WHERE doc @> '{"tags":[{"term":"paris"}, {"term":"food"}]}';</codeblock>
      <p>使用这个谓词的查询可以完成相同的事情。</p>
      <codeblock>SELECT doc->'site_name' FROM websites
  WHERE doc->'tags' @> '[{"term":"paris"}, {"term":"food"}]';</codeblock>
      <p>然而，第二种方法的灵活性较低，而且效率通常也较低。</p>
      <p>另一方面，json存在操作符不是嵌套的：它只在json值的顶层查找指定的键或数组元素。</p>
    </body>
  </topic>
  <topic id="topic_aqt_1tw_mq">
    <title>jsonb索引</title>
    <body>
      <p>Greenplum数据库<codeph>jsonb</codeph>数据类型，支持GIN, btree,和hash索引。<ul id="ul_mqh_pq2_rfb">
          <li><xref href="#topic_yjx_dq2_rfb" format="dita"/></li>
          <li><xref href="#topic_ahb_5ly_wq" format="dita"/></li>
        </ul></p>
    </body>
    <topic id="topic_yjx_dq2_rfb">
      <title>jsonb数据上的GIN索引/title>
      <body>
        <p>可以使用GIN索引有效地搜索出现在大量<codeph>jsonb</codeph>文档（基准）中的键或键/值对。两个GIN操作符类，提供不同的性能和灵活性权衡。</p>
        <p><varname>jsonb</varname>的默认GIN操作符类支持带<codeph>@></codeph>, <codeph>?</codeph>, <codeph>?&amp;</codeph> 和 <codeph>?|</codeph>操作符的查询。（有关这些运算符实现的语义的详细信息，请参见表 <xref href="#topic_o5y_14w_2z/table_dcb_y3w_mq" format="dita"/>
            ）。使用此操作符类创建索引的示例如下：</p>
        <codeblock>CREATE INDEX idxgin ON api USING gin (jdoc);</codeblock>
        <p>非默认的GIN运算符类<codeph>jsonb_path_ops</codeph>仅支持为<codeph>@></codeph>运算符编制索引。使用此运算符类创建索引的示例如下：</p>
        <pre>CREATE INDEX idxginp ON api USING gin (jdoc jsonb_path_ops);</pre>
        <p>考虑一个表的示例，该表存储从第三方Web服务检索到的JSON文档，并且具有文档化的模式定义。这是一个典型的文档：</p>
        <codeblock>{
    "guid": "9c36adc1-7fb5-4d5b-83b4-90356a46061a",
    "name": "Angela Barton",
    "is_active": true,
    "company": "Magnafone",
    "address": "178 Howard Place, Gulf, Washington, 702",
    "registered": "2009-11-07T08:53:22 +08:00",
    "latitude": 19.793713,
    "longitude": 86.513373,
    "tags": [
        "enim",
        "aliquip",
        "qui"
    ]
}</codeblock>
        <p>JSON文档存储在<codeph>jsonb</codeph>列中的一个名为API的表中。如果在此列上创建了GIN索引，则以下查询可以使用该索引：
           </p>
        <codeblock>-- 查找关键词“公司”具有“magnafone”价值的文档：
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @> '{"company": "Magnafone"}';</codeblock>
        <p>但是，索引不能用于以下查询。操作符<codeph>?</codeph> 是可索引的，但是，比较不会直接应用于索引列<codeph>jdoc</codeph>:
           </p>
        <codeblock>-- Find documents in which the key "tags" contains key or array element "qui"
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc -> 'tags' ? 'qui';</codeblock>
        <p>通过适当地使用表达式索引，上述查询可以使用索引。如果在<codeph>tags</codeph> 键中查询特定项是常见的，那么定义这样的索引可能是值得的：
            </p>
        <codeblock>CREATE INDEX idxgintags ON api USING gin ((jdoc -> 'tags'));</codeblock>
        <p>现在，<codeph>WHERE</codeph>子句 <codeph>jdoc -> 'tags' ? 'qui'</codeph>被认为是可索引运算符的应用<codeph>?</codeph> 到索引表达式<codeph>jdoc -> 'tags'</codeph>。有关表达式索引的信息，请参阅表达式索引
            <xref href="../../ddl/ddl-index.xml#topic_tfz_3vz_4fb"/>。</p>
        <p>Another approach to querying JSON documents is to exploit containment, for example:</p>
        <pre>-- Find documents in which the key "tags" contains array element "qui"
SELECT jdoc->'guid', jdoc->'name' FROM api WHERE jdoc @> '{"tags": ["qui"]}';
</pre>
        <p>A simple GIN index on the <codeph>jdoc</codeph> column can support this query. However,
          the index will store copies of every key and value in the <codeph>jdoc</codeph> column,
          whereas the expression index of the previous example stores only data found under the tags
          key. While the simple-index approach is far more flexible (since it supports queries about
          any key), targeted expression indexes are likely to be smaller and faster to search than a
          simple index.</p>
        <p>Although the <codeph>jsonb_path_ops</codeph> operator class supports only queries with
          the <codeph>@></codeph> operator, it has performance advantages over the default operator
          class <codeph>jsonb_ops</codeph>. A <codeph>jsonb_path_ops</codeph> index is usually much
          smaller than a <codeph>jsonb_ops</codeph> index over the same data, and the specificity of
          searches is better, particularly when queries contain keys that appear frequently in the
          data. Therefore search operations typically perform better than with the default operator
          class.</p>
        <p>The technical difference between a <codeph>jsonb_ops</codeph> and a
            <codeph>jsonb_path_ops</codeph> GIN index is that the former creates independent index
          items for each key and value in the data, while the latter creates index items only for
          each value in the data.</p>
        <note>For this discussion, the term <i>value</i> includes array elements, though JSON
          terminology sometimes considers array elements distinct from values within objects.</note>
        <p>Basically, each <codeph>jsonb_path_ops</codeph> index item is a hash of the value and the
          key(s) leading to it; for example to index <codeph>{"foo": {"bar": "baz"}}</codeph>, a
          single index item would be created incorporating all three of <codeph>foo</codeph>,
            <codeph>bar</codeph>, and <codeph>baz</codeph> into the hash value. Thus a containment
          query looking for this structure would result in an extremely specific index search; but
          there is no way at all to find out whether <codeph>foo</codeph> appears as a key. On the
          other hand, a <codeph>jsonb_ops</codeph> index would create three index items representing
            <codeph>foo</codeph>, <codeph>bar</codeph>, and <codeph>baz</codeph> separately; then to
          do the containment query, it would look for rows containing all three of these items.
          While GIN indexes can perform such an <codeph>AND</codeph> search fairly efficiently, it
          will still be less specific and slower than the equivalent <codeph>jsonb_path_ops</codeph>
          search, especially if there are a very large number of rows containing any single one of
          the three index items.</p>
        <p>A disadvantage of the <codeph>jsonb_path_ops</codeph> approach is that it produces no
          index entries for JSON structures not containing any values, such as <codeph>{"a":
            {}}</codeph>. If a search for documents containing such a structure is requested, it
          will require a full-index scan, which is quite slow. <codeph>jsonb_path_ops</codeph> is
          ill-suited for applications that often perform such searches.</p>
      </body>
    </topic>
    <topic id="topic_ahb_5ly_wq">
      <title>Btree and Hash Indexes on jsonb Data</title>
      <body>
        <p><codeph>jsonb</codeph> also supports <codeph>btree</codeph> and <codeph>hash</codeph>
          indexes. These are usually useful only when it is important to check the equality of
          complete JSON documents. </p>
        <p>For completeness the <codeph>btree</codeph> ordering for <codeph>jsonb</codeph> datums
          is:</p>
        <pre>Object > Array > Boolean > Number > String > Null

Object with n pairs > object with n - 1 pairs

Array with n elements > array with n - 1 elements</pre>
        <p>Objects with equal numbers of pairs are compared in the order:</p>
        <pre>key-1, value-1, key-2 ...</pre>
        <p>Object keys are compared in their storage order. In particular, since shorter keys are
          stored before longer keys, this can lead to orderings that might not be intuitive, such
          as:</p>
        <pre>{ "aa": 1, "c": 1} > {"b": 1, "d": 1}</pre>
        <p>Similarly, arrays with equal numbers of elements are compared in the order:</p>
        <pre>element-1, element-2 ...</pre>
        <p>Primitive JSON values are compared using the same comparison rules as for the underlying
          Greenplum Database data type. Strings are compared using the default database
          collation.</p>
      </body>
    </topic>
  </topic>
  <topic id="topic_gn4_x3w_mq">
    <title>JSON Functions and Operators</title>
    <body>
      <p>Greenplum Database includes built-in functions and operators that create and manipulate
        JSON data.<ul id="ul_ypx_f4w_2z">
          <li><xref href="#topic_o5y_14w_2z" format="dita"/></li>
          <li><xref href="#topic_u4s_wnw_2z" format="dita"/></li>
          <li><xref href="#topic_rvp_lk3_sfb" format="dita"/></li>
          <li><xref href="#topic_z5d_snw_2z" format="dita"/></li>
        </ul></p>
      <note>For <codeph>json</codeph> data type values, all key/value pairs are kept even if a JSON
        object contains duplicate keys. For duplicate keys, JSON processing functions consider the
        last value as the operative one. For the <codeph>jsonb</codeph> data type, duplicate object
        keys are not kept. If the input includes duplicate keys, only the last value is kept. See
          <xref href="#topic_upc_tcs_fz" format="dita"/>.</note>
    </body>
    <topic id="topic_o5y_14w_2z">
      <title>JSON Operators</title>
      <body>
        <p>This table describes the operators that are available for use with the
            <codeph>json</codeph> and <codeph>jsonb</codeph> data types.</p>
        <table id="table_e41_y3w_mq">
          <title><varname>json</varname> and <codeph>jsonb</codeph> Operators</title>
          <tgroup cols="5">
            <colspec colnum="1" colname="col1" colwidth="1*"/>
            <colspec colnum="2" colname="col2" colwidth="1.17*"/>
            <colspec colnum="3" colname="col3" colwidth="2.79*"/>
            <colspec colnum="4" colname="col4" colwidth="2.78*"/>
            <colspec colnum="5" colname="col5" colwidth="1.92*"/>
            <thead>
              <row>
                <entry>Operator</entry>
                <entry>Right Operand Type</entry>
                <entry>Description</entry>
                <entry>Example</entry>
                <entry>Example Result</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>-></codeph>
                </entry>
                <entry>
                  <codeph>int</codeph>
                </entry>
                <entry>Get the JSON array element (indexed from zero).</entry>
                <entry>
                  <codeph>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2</codeph>
                </entry>
                <entry>
                  <codeph>{"c":"baz"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>-></codeph>
                </entry>
                <entry>
                  <codeph>text</codeph>
                </entry>
                <entry>Get the JSON object field by key.</entry>
                <entry>
                  <codeph>'{"a": {"b":"foo"}}'::json->'a'</codeph>
                </entry>
                <entry>
                  <codeph>{"b":"foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>->></codeph>
                </entry>
                <entry>
                  <codeph>int</codeph>
                </entry>
                <entry>Get the JSON array element as <codeph>text</codeph>.</entry>
                <entry>
                  <codeph>'[1,2,3]'::json->>2</codeph>
                </entry>
                <entry>
                  <codeph>3</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>->></codeph>
                </entry>
                <entry>
                  <codeph>text</codeph>
                </entry>
                <entry>Get the JSON object field as <codeph>text</codeph>.</entry>
                <entry>
                  <codeph>'{"a":1,"b":2}'::json->>'b'</codeph>
                </entry>
                <entry>
                  <codeph>2</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>#></codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>Get the JSON object at specified path.</entry>
                <entry><codeph>'{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}</codeph>'</entry>
                <entry>
                  <codeph>{"c": "foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>#>></codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>Get the JSON object at specified path as <codeph>text</codeph>.</entry>
                <entry>
                  <codeph>'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'</codeph>
                </entry>
                <entry>
                  <codeph>3</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note>There are parallel variants of these operators for both the <codeph>json</codeph> and
            <codeph>jsonb</codeph> data types. The field, element, and path extraction operators
          return the same data type as their left-hand input (either <codeph>json</codeph> or
            <codeph>jsonb</codeph>), except for those specified as returning <codeph>text</codeph>,
          which coerce the value to <codeph>text</codeph>. The field, element, and path extraction
          operators return <codeph>NULL</codeph>, rather than failing, if the JSON input does not
          have the right structure to match the request; for example if no such element
          exists.</note>
        <p>Operators that require the <codeph>jsonb</codeph> data type as the left operand are
          described in the following table. Many of these operators can be indexed by
            <codeph>jsonb</codeph> operator classes. For a full description of
            <codeph>jsonb</codeph> containment and existence semantics, see <xref
            href="#topic_isx_2tw_mq" format="dita"/>. For information about how these operators can
          be used to effectively index <codeph>jsonb</codeph> data, see <xref
            href="#topic_aqt_1tw_mq" format="dita"/>.</p>
        <table id="table_dcb_y3w_mq">
          <title><codeph>jsonb</codeph> Operators</title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1" colwidth="1*"/>
            <colspec colnum="2" colname="col2" colwidth="1.94*"/>
            <colspec colnum="3" colname="col3" colwidth="4.59*"/>
            <colspec colnum="4" colname="col4" colwidth="2.5*"/>
            <thead>
              <row>
                <entry>Operator</entry>
                <entry>Right Operand Type</entry>
                <entry>Description</entry>
                <entry>Example</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>@></codeph>
                </entry>
                <entry>
                  <codeph>jsonb</codeph>
                </entry>
                <entry>Does the left JSON value contain within it the right value?</entry>
                <entry>
                  <codeph>'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>&lt;@</codeph>
                </entry>
                <entry>
                  <codeph>jsonb</codeph>
                </entry>
                <entry>Is the left JSON value contained within the right value?</entry>
                <entry>
                  <codeph>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>?</codeph>
                </entry>
                <entry>
                  <codeph>text</codeph>
                </entry>
                <entry>Does the key/element string exist within the JSON value?</entry>
                <entry>
                  <codeph>'{"a":1, "b":2}'::jsonb ? 'b'</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>?|</codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>Do any of these key/element strings exist?</entry>
                <entry>
                  <codeph>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>?&amp;</codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>Do all of these key/element strings exist?</entry>
                <entry>
                  <codeph>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p>The standard comparison operators in the following table are available only for the
            <codeph>jsonb</codeph> data type, not for the <codeph>json</codeph> data type. They
          follow the ordering rules for B-tree operations described in <xref
            href="#topic_aqt_1tw_mq" format="dita"/>.</p>
        <table id="table_j4w_z5n_vq">
          <title><codeph>jsonb</codeph> Comparison Operators</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <thead>
              <row>
                <entry>Operator</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>&lt;</codeph>
                </entry>
                <entry>less than</entry>
              </row>
              <row>
                <entry>
                  <codeph>></codeph>
                </entry>
                <entry>greater than</entry>
              </row>
              <row>
                <entry>
                  <codeph>&lt;=</codeph>
                </entry>
                <entry>less than or equal to</entry>
              </row>
              <row>
                <entry>
                  <codeph>>=</codeph>
                </entry>
                <entry>greater than or equal to</entry>
              </row>
              <row>
                <entry>
                  <codeph>=</codeph>
                </entry>
                <entry>equal</entry>
              </row>
              <row>
                <entry><codeph>&lt;></codeph> or <codeph>!=</codeph></entry>
                <entry>not equal</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note>The <codeph>!=</codeph> operator is converted to <codeph>&lt;></codeph> in the parser
          stage. It is not possible to implement <codeph>!=</codeph> and <codeph>&lt;></codeph>
          operators that do different things.</note>
      </body>
    </topic>
    <topic id="topic_u4s_wnw_2z">
      <title>JSON Creation Functions</title>
      <body>
        <p>This table describes the functions that create <codeph>json</codeph> data type values.
          (Currently, there are no equivalent functions for <codeph>jsonb</codeph>, but you can cast
          the result of one of these functions to <codeph>jsonb</codeph>.)</p>
        <table id="table_sqb_y3w_mb">
          <title>JSON Creation Functions </title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <colspec colnum="3" colname="col3"/>
            <colspec colnum="4" colname="col4"/>
            <thead>
              <row>
                <entry>Function</entry>
                <entry>Description</entry>
                <entry>Example</entry>
                <entry>Example Result</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>to_json(anyelement)</codeph>
                </entry>
                <entry>Returns the value as a JSON object. Arrays and composites are processed
                  recursively and are converted to arrays and objects. If the input contains a cast
                  from the type to <codeph>json</codeph>, the cast function is used to perform the
                  conversion; otherwise, a JSON scalar value is produced. For any scalar type other
                  than a number, a Boolean, or a null value, the text representation will be used,
                  properly quoted and escaped so that it is a valid JSON string.</entry>
                <entry>
                  <codeph>to_json('Fred said "Hi."'::text)</codeph>
                </entry>
                <entry>
                  <codeph>"Fred said \"Hi.\""</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>array_to_json(anyarray [, pretty_bool])</codeph>
                </entry>
                <entry>Returns the array as a JSON array. A multidimensional array becomes a JSON
                  array of arrays. <p>Line feeds will be added between dimension-1 elements if
                      <codeph>pretty_bool</codeph> is true.</p></entry>
                <entry>
                  <codeph>array_to_json('{{1,5},{99,100}}'::int[])</codeph>
                </entry>
                <entry>
                  <codeph>[[1,5],[99,100]]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>row_to_json(record [, pretty_bool])</codeph>
                </entry>
                <entry>Returns the row as a JSON object. <p>Line feeds will be added between level-1
                    elements if <codeph>pretty_bool</codeph> is true.</p></entry>
                <entry>
                  <codeph>row_to_json(row(1,'foo'))</codeph>
                </entry>
                <entry>
                  <codeph>{"f1":1,"f2":"foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_build_array(VARIADIC "any"</codeph>)</entry>
                <entry>Builds a possibly-heterogeneously-typed JSON array out of a
                    <codeph>VARIADIC</codeph> argument list.</entry>
                <entry>
                  <codeph>json_build_array(1,2,'3',4,5)</codeph>
                </entry>
                <entry>
                  <codeph>[1, 2, "3", 4, 5]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>json_build_object(VARIADIC "any")</codeph>
                </entry>
                <entry>Builds a JSON object out of a <codeph>VARIADIC</codeph> argument list. The
                  argument list is taken in order and converted to a set of key/value pairs.</entry>
                <entry>
                  <codeph>json_build_object('foo',1,'bar',2)</codeph>
                </entry>
                <entry>
                  <codeph>{"foo": 1, "bar": 2}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object(text[])</codeph>
                </entry>
                <entry>Builds a JSON object out of a text array. The array must be either a one or a
                  two dimensional array.<p>The one dimensional array must have an even number of
                    elements. The elements are taken as key/value pairs. </p><p>For a two
                    dimensional array, each inner array must have exactly two elements, which are
                    taken as a key/value pair.</p></entry>
                <entry>
                  <p>
                    <codeph>json_object('{a, 1, b, "def", c, 3.5}')</codeph>
                  </p>
                  <p>
                    <codeph>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</codeph>
                  </p>
                </entry>
                <entry>
                  <codeph>{"a": "1", "b": "def", "c": "3.5"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object(keys text[], values text[])</codeph>
                </entry>
                <entry>Builds a JSON object out of a text array. This form of
                    <codeph>json_object</codeph> takes keys and values pairwise from two separate
                  arrays. In all other respects it is identical to the one-argument form.</entry>
                <entry>
                  <codeph>json_object('{a, b}', '{1,2}')</codeph>
                </entry>
                <entry>
                  <codeph>{"a": "1", "b": "2"}</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note><codeph>array_to_json</codeph> and <codeph>row_to_json</codeph> have the same behavior
          as <codeph>to_json</codeph> except for offering a pretty-printing option. The behavior
          described for <codeph>to_json</codeph> likewise applies to each individual value converted
          by the other JSON creation functions.</note>
        <note>The <xref href="../../../ref_guide/modules/hstore.xml#topic_vcn_jkq_1bb">hstore
            module</xref> contains functions that cast from <codeph>hstore</codeph> to
            <codeph>json</codeph>, so that <codeph>hstore</codeph> values converted via the JSON
          creation functions will be represented as JSON objects, not as primitive string
          values.</note>
      </body>
    </topic>
    <topic id="topic_rvp_lk3_sfb">
      <title>JSON Aggregate Functions</title>
      <body>
        <p>This table shows the functions aggregate records to an array of JSON objects and pairs of
          values to a JSON object </p>
        <table id="table_kkr_mk3_sfb">
          <title>JSON Aggregate Functions</title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <colspec colnum="3" colname="col3"/>
            <colspec colnum="4" colname="col4"/>
            <thead>
              <row>
                <entry>Function</entry>
                <entry>Argument Types</entry>
                <entry>Return Type</entry>
                <entry>Description</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>json_agg(record)</codeph>
                </entry>
                <entry>
                  <codeph>record</codeph>
                </entry>
                <entry>
                  <codeph>json</codeph>
                </entry>
                <entry>Aggregates records as a JSON array of objects.</entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object_agg(name, value)</codeph>
                </entry>
                <entry>
                  <codeph>("any", "any")</codeph>
                </entry>
                <entry>
                  <codeph>json</codeph>
                </entry>
                <entry>Aggregates name/value pairs as a JSON object.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </body>
    </topic>
    <topic id="topic_z5d_snw_2z">
      <title>JSON Processing Functions</title>
      <body>
        <p>This table shows the functions that are available for processing <codeph>json</codeph>
          and <codeph>jsonb</codeph> values.</p>
        <p>Many of these processing functions and operators convert Unicode escapes in JSON strings
          to the appropriate single character. This is a not an issue if the input data type is
            <codeph>jsonb</codeph>, because the conversion was already done. However, for
            <codeph>json</codeph> data type input, this might result in an error being thrown. See
            <xref href="#topic_upc_tcs_fz" format="dita"/>.</p>
        <table id="table_wfc_y3w_mb">
          <title>JSON Processing Functions</title>
          <tgroup cols="5">
            <colspec colnum="1" colname="col1" colwidth="1.08*"/>
            <colspec colnum="2" colname="col2" colwidth="1*"/>
            <colspec colnum="3" colname="col3" colwidth="1.01*"/>
            <colspec colnum="4" colname="col4" colwidth="1.24*"/>
            <colspec colnum="5" colname="col5" colwidth="1.01*"/>
            <thead>
              <row>
                <entry>Function</entry>
                <entry>Return Type</entry>
                <entry>Description</entry>
                <entry>Example</entry>
                <entry>Example Result</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>json_array_length(json)</codeph>
                  <p>
                    <codeph>jsonb_array_length(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>int</codeph>
                </entry>
                <entry>Returns the number of elements in the outermost JSON array.</entry>
                <entry><codeph>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</codeph>
                </entry>
                <entry>
                  <codeph>5</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_each(json)</codeph>
                  <p><codeph>jsonb_each(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof key text, value json</codeph>
                  <p><codeph>setof key text, value jsonb</codeph>
                  </p>
                </entry>
                <entry>Expands the outermost JSON object into a set of key/value pairs.</entry>
                <entry><codeph>select * from json_each('{"a":"foo", "b":"bar"}')</codeph>
                </entry>
                <entry>
                  <pre> key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_each_text(json)</codeph>
                  <p><codeph>jsonb_each_text(jsonb)</codeph>
                  </p>
                </entry>
                <entry><codeph>setof key text, value text</codeph>
                </entry>
                <entry>Expands the outermost JSON object into a set of key/value pairs. The returned
                  values will be of type <codeph>text</codeph>.</entry>
                <entry><codeph>select * from json_each_text('{"a":"foo", "b":"bar"}')</codeph>
                </entry>
                <entry>
                  <pre> key | value
-----+-------
 a   | foo
 b   | bar
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_extract_path(from_json json, VARIADIC path_elems
                    text[])</codeph>
                  <p><codeph>jsonb_extract_path(from_json jsonb, VARIADIC path_elems
                      text[])</codeph>
                  </p></entry>
                <entry>
                  <p><codeph>json</codeph>
                  </p>
                  <p><codeph>jsonb</codeph>
                  </p>
                </entry>
                <entry>Returns the JSON value pointed to by <codeph>path_elems</codeph> (equivalent
                  to <codeph>#></codeph> operator).</entry>
                <entry><codeph>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</codeph>
                </entry>
                <entry>
                  <codeph>{"f5":99,"f6":"foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_extract_path_text(from_json json, VARIADIC path_elems
                    text[])</codeph>
                  <p><codeph>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems
                      text[])</codeph>
                  </p></entry>
                <entry><codeph>text</codeph>
                </entry>
                <entry>Returns the JSON value pointed to by <codeph>path_elems</codeph> as text.
                  Equivalent to <codeph>#>></codeph> operator.</entry>
                <entry><codeph>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4',
                    'f6')</codeph>
                </entry>
                <entry>
                  <codeph>foo</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_object_keys(json)</codeph>
                  <p><codeph>jsonb_object_keys(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof text</codeph>
                </entry>
                <entry>Returns set of keys in the outermost JSON object.</entry>
                <entry><codeph>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</codeph>
                </entry>
                <entry>
                  <pre> json_object_keys
------------------
 f1
 f2
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_populate_record(base anyelement, from_json
                      json)</codeph><p><codeph>jsonb_populate_record(base anyelement, from_json
                      jsonb)</codeph>
                  </p></entry>
                <entry><codeph>anyelement</codeph>
                </entry>
                <entry>Expands the object in <codeph>from_json</codeph> to a row whose columns match
                  the record type defined by base. See <xref href="#topic_z5d_snw_2z/json_proc_1"
                    format="dita">Note 1</xref>.</entry>
                <entry><codeph>select * from json_populate_record(null::myrowtype,
                    '{"a":1,"b":2}')</codeph>
                </entry>
                <entry>
                  <pre> a | b
---+---
 1 | 2
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_populate_recordset(base anyelement, from_json json)</codeph>
                  <p><codeph>jsonb_populate_recordset(base anyelement, from_json jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof anyelement</codeph>
                </entry>
                <entry>Expands the outermost array of objects in <codeph>from_json</codeph> to a set
                  of rows whose columns match the record type defined by base. See <xref
                    href="#topic_z5d_snw_2z/json_proc_1" format="dita">Note 1</xref>.</entry>
                <entry><codeph>select * from json_populate_recordset(null::myrowtype,
                    '[{"a":1,"b":2},{"a":3,"b":4}]')</codeph>
                </entry>
                <entry>
                  <pre> a | b
---+---
 1 | 2
 3 | 4
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_array_elements(json)</codeph>
                  <p><codeph>jsonb_array_elements(jsonb</codeph>)</p></entry>
                <entry>
                  <p><codeph>setof json</codeph>
                  </p>
                  <p><codeph>setof jsonb</codeph>
                  </p>
                </entry>
                <entry>Expands a JSON array to a set of JSON values.</entry>
                <entry><codeph>select * from json_array_elements('[1,true, [2,false]]')</codeph>
                </entry>
                <entry>
                  <pre>   value
-----------
 1
 true
 [2,false]
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_array_elements_text(json)</codeph>
                  <p><codeph>jsonb_array_elements_text(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof text</codeph>
                </entry>
                <entry>Expands a JSON array to a set of <codeph>text</codeph> values.</entry>
                <entry><codeph>select * from json_array_elements_text('["foo", "bar"]')</codeph>
                </entry>
                <entry>
                  <pre>   value
-----------
 foo
 bar
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_typeof(json)</codeph><p><codeph>jsonb_typeof(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>text</codeph>
                </entry>
                <entry>Returns the type of the outermost JSON value as a text string. Possible types
                  are <codeph>object</codeph>, <codeph>array</codeph>, <codeph>string</codeph>,
                    <codeph>number</codeph>, <codeph>boolean</codeph>, and <codeph>null</codeph>.
                  See <xref href="#topic_z5d_snw_2z/json_proc_2" format="dita">Note
                  2</xref>.</entry>
                <entry><codeph>json_typeof('-123.4')</codeph>
                </entry>
                <entry>
                  <codeph>number</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_to_record(json)</codeph><p><codeph>jsonb_to_record(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>record</codeph>
                </entry>
                <entry>Builds an arbitrary record from a JSON object. See <xref
                    href="#topic_z5d_snw_2z/json_proc_1" format="dita">Note 1</xref>. <p>As with all
                    functions returning record, the caller must explicitly define the structure of
                    the record with an <codeph>AS</codeph> clause.</p></entry>
                <entry><codeph>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a
                    int, b text, d text)</codeph>
                </entry>
                <entry>
                  <pre> a |    b    | d
---+---------+---
 1 | [1,2,3] |
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_to_recordset(json)</codeph>
                  <p><codeph>jsonb_to_recordset(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof record</codeph>
                </entry>
                <entry>Builds an arbitrary set of records from a JSON array of objects See <xref
                    href="#topic_z5d_snw_2z/json_proc_1" format="dita">Note 1</xref>. <p>As with all
                    functions returning record, the caller must explicitly define the structure of
                    the record with an <codeph>AS</codeph> clause.</p></entry>
                <entry><codeph>select * from
                    json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b
                    text);</codeph>
                </entry>
                <entry>
                  <pre> a |  b
---+-----
 1 | foo
 2 |
</pre>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note id="json_record">
          <ol id="ol_umc_2sg_pfb">
            <li id="json_proc_1">The examples for the functions
                <codeph>json_populate_record()</codeph>, <codeph>json_populate_recordset()</codeph>,
                <codeph>json_to_record()</codeph> and <codeph>json_to_recordset()</codeph> use
              constants. However, the typical use would be to reference a table in the
                <codeph>FROM</codeph> clause and use one of its <codeph>json</codeph> or
                <codeph>jsonb</codeph> columns as an argument to the function. The extracted key
              values can then be referenced in other parts of the query. For example the value can
              be referenced in <codeph>WHERE</codeph> clauses and target lists. Extracting multiple
              values in this way can improve performance over extracting them separately with
              per-key operators.<p>JSON keys are matched to identical column names in the target row
                type. JSON type coercion for these functions might not result in desired values for
                some types. JSON fields that do not appear in the target row type will be omitted
                from the output, and target columns that do not match any JSON field will be
                  <codeph>NULL</codeph>.</p></li>
            <li id="json_proc_2">The <codeph>json_typeof</codeph> function null return value of
                <codeph>null</codeph> should not be confused with a SQL <codeph>NULL</codeph>. While
              calling <codeph>json_typeof('null'::json)</codeph> will return <codeph>null</codeph>,
              calling <codeph>json_typeof(NULL::json)</codeph> will return a SQL
                <codeph>NULL</codeph>.</li>
          </ol>
        </note>
      </body>
    </topic>
  </topic>
</topic>
