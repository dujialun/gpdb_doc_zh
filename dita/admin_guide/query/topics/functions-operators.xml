<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic26" xml:lang="en">
    <title id="in151167">使用函数和操作符</title>
    <shortdesc>用户定义和内置函数和运算符的说明。</shortdesc>
    <body>
        <ul>
            <li id="in140953">
                <xref format="dita" href="#topic27" type="topic"/></li>
            <li id="in141620">
                <xref format="dita" href="#topic28" type="topic"/>
            </li>
            <li id="in141625">
                <xref format="dita" href="#topic29" type="topic"/>
            </li>
            <li id="in184735">
                <xref format="dita" href="#topic30" type="topic"/>
            </li>
            <li id="in184739">
                <xref format="dita" href="#topic31" type="topic"/>
            </li>
        </ul>
    </body>
    <topic id="topic27" xml:lang="en">
        <title id="in201560">在Greenplum数据库中使用函数</title>
        <body>
            <p>在Greenplum数据库中调用函数时，函数属性控制函数的执行。易变性属性 (<codeph>IMMUTABLE</codeph>,
                    <codeph>STABLE</codeph>, <codeph>VOLATILE</codeph>) 和<codeph>EXECUTE
                    ON</codeph> 属性控制函数执行的两个不同方面。一般来说，易变性指示函数执行时间， <codeph>EXECUTE
                    ON</codeph> 指示执行位置。易变性属性是基于PostgreSQL的属性, <codeph>EXECUTE ON</codeph> 属性是Greenplum的属性。</p>
            <p>例如，使用<codeph>IMMUTABLE</codeph>属性定义的函数可以在查询计划时执行，而使用<codeph>VOLATILE</codeph>属性定义的函数，必须对查询中每一行执行。
                使用<codeph>EXECUTE ON MASTER</codeph>属性的函数仅在主实例上执行，而使用<codeph>EXECUTE ON ALL
                    SEGMENTS</codeph>属性的函数在所有主segment实例（而不是主服务器）上执行。
                 </p>
            <p>这些表总结了Greenplum数据库基于这些属性，对函数执行的假设。</p>
            <table id="in201681">
                <title>Greenplum数据库的函数易变性</title>
                <tgroup cols="4">
                    <colspec colname="col1" colnum="1" colwidth="77*"/>
                    <colspec colname="col2" colnum="2" colwidth="86*"/>
                    <colspec colname="col3" colnum="3" colwidth="144*"/>
                    <colspec colname="col4" colnum="4" colwidth="144*"/>
                    <thead>
                        <row>
                            <entry colname="col1">函数属性</entry>
                            <entry colname="col2">Greenplum支持</entry>
                            <entry colname="col3">描述</entry>
                            <entry colname="col4">注释</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colname="col1">IMMUTABLE</entry>
                            <entry colname="col2">支持</entry>
                            <entry colname="col3">仅直接依赖信息参数列表。如果给定相同的参数值，则始终返回同样的结果。</entry>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">STABLE</entry>
                            <entry colname="col2">大部分情况下支持</entry>
                            <entry colname="col3">在一个单一表扫描中，相同的参数值返回相同的结果，但是不同的SQL语句结果会改变。</entry>
                            <entry colname="col4">结果依赖于数据库查找或者参数值。<codeph>current_timestamp</codeph>函数族是<codeph>STABLE</codeph>的，在一次执行中值不会改变。</entry>
                        </row>
                        <row>
                            <entry colname="col1">VOLATILE</entry>
                            <entry colname="col2">受限</entry>
                            <entry colname="col3">在一个单一表扫描中函数值可能会改变。例如：<codeph>random()</codeph>,
                                <codeph>timeofday()</codeph>，这是默认属性。</entry>
                            <entry colname="col4">任何有副作用的函数都是volatile，即使它的结果是可预测的也一样。例如：<codeph>setval()</codeph>。
                            </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <table id="table_cnz_4ng_gcb">
                <title>Greenplum数据库的EXECUTE ON函数属性 </title>
                <tgroup cols="3">
                    <colspec colname="col1" colnum="1" colwidth="77*"/>
                    <colspec colname="col3" colnum="2" colwidth="144*"/>
                    <colspec colname="col4" colnum="3" colwidth="144*"/>
                    <thead>
                        <row>
                            <entry colname="col1">函数属性</entry>
                            <entry colname="col3">描述</entry>
                            <entry colname="col4">注释</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colname="col1">EXECUTE ON ANY</entry>
                            <entry colname="col3">表示函数可以在master或任意segment实例上执行，并且返回相同的结果，而不管它在何处执行。这是默认属性。</entry>
                            <entry colname="col4">Greenplum数据库决定函数的执行位置。</entry>
                        </row>
                        <row>
                            <entry colname="col1">EXECUTE ON MASTER</entry>
                            <entry colname="col3">表示必须在master实例上执行函数。</entry>
                            <entry colname="col4">如果用户定义函数执行查询以访问表，请指定此属性。 </entry>
                        </row>
                        <row>
                            <entry colname="col1">EXECUTE ON ALL SEGMENTS</entry>
                            <entry colname="col3">表示对于每个调用，函数必须在所有主segment实例上执行，而不是在master上执行。</entry>
                            <entry colname="col4"/>
                        </row>
                    </tbody>
                </tgroup>
            </table>
            <p>您可以使用psql <codeph>\df+ <varname>function</varname></codeph>命令显示函数的易变性和<codeph>EXECUTE
                ON</codeph>属性。</p>
            <p>更多有关Greenplum数据库函数易变性分类的信息，请参考PostgreSQL文档<xref
                    href="https://www.postgresql.org/docs/9.4/xfunc-volatility.html"
                    scope="external" format="html">函数易变性分类</xref>
                </p>
            <p>更多关于<codeph>EXECUTE ON</codeph>属性的信息, 参看 <codeph><xref
                        href="../../../ref_guide/sql_commands/CREATE_FUNCTION.xml#topic1"
                        format="dita" scope="peer">创建函数</xref></codeph>.</p>
            <p>在Greenplum数据库中，数据被划分为多个段-每个段都是一个不同的PostgreSQL数据库。为了防止不一致或意外的结果，如果函数包含SQL命令或者任意修改数据库的方式，请不要在segment级别执行被分类为volatile的函数。
                例如，不允许对Greenplum数据库中的分布式数据<codeph>setval()</codeph>等函数，因为它们可能导致段实例之间的数据不一致。</p>
            <p>函数可以对segment上的复制表（<codeph>DISTRIBUTED REPLICATED</codeph>）执行只读查询，但修改数据的任何SQL命令都必须在master实例上执行。 </p>
            <p>为了确保数据的一致性，您可以在主服务器上安全地运行语句来调用使用<codeph>VOLATILE
            </codeph>和<codeph>STABLE</codeph>的函数。例如，下面的语句在master上运行（不带FROM子句的语句）：</p>
            <p>
                <codeblock>SELECT setval('myseq', 201);
SELECT foo();</codeblock>
            </p>
            <p>如果语句有一个包含分布式表的<codeph>FROM</codeph>子句，而<codeph>FROM</codeph>子句中的函数返回一组行，则该语句可以在以下segment上运行：</p>
            <p>
                <codeblock>SELECT * from foo();</codeblock>
            </p>
            <p>Greenplum数据库不支持返回表引用（<codeph>rangeFuncs</codeph>）的函数或使用<codeph>refCursor</codeph>数据类型的函数。</p>
        </body>
        <topic id="topic281" xml:lang="en">
            <title id="in1414519">函数易变性和计划缓冲</title>
            <body>
                <p>对于计划和立即执行的简单交互式查询，<codeph>STABLE</codeph>和<codeph>IMMUTABLE
                </codeph>的函数易变性类别之间的差异相对较小。无论是在计划期间执行一次函数，还是在查询执行启动期执行一次函数，都无关紧要。
                    但是，当您保存计划并稍后重用它时，会有很大的不同。如果把一个函数误标为<codeph>IMMUTABLE
                    </codeph>，Greenplum数据库可能在规划时会过早地把它折叠成一个常量，可能会在计划的后续执行期间重用过时的值。当使用 <codeph>PREPARE</codeph>
                    语句或使用PL/pgSQL之类的语言缓存计划时，可能会遇到这种危险。</p>
            </body>
        </topic>
    </topic>
    <topic id="topic28" xml:lang="en">
        <title id="in141451">用户定义的函数</title>
        <body>
            <p>Greenplum数据库支持用户定义的函数。更多信息请见PostgreSQL文档中的 <xref format="html"
                    href="https://www.postgresql.org/docs/9.4/extend.html" scope="external"
                    >Extending SQL</xref> </p>
            <p>使用<codeph>CREATE FUNCTION</codeph>语句注册用户定义的函数，它们可以按在<xref format="dita" href="#topic27" type="topic"/>中所述的方式被使用。
                默认情况下，用户定义的函数被声明为<codeph>VOLATILE</codeph>，因此如果用户定义的函数是<codeph>IMMUTABLE</codeph>或者<codeph>STABLE</codeph>，必须在注册该函数时指定正确的易变性级别。</p>
            <p>默认情况下，用户定义的函数被声明为<codeph>EXECUTE ON
                ANY</codeph>。只有当函数在master实例上执行时，才支持执行查询以访问表的函数，除非函数可以执行仅访问segment实例上复制表的<codeph>SELECT
            </codeph>命令。访问散列分布表或随机分布表的函数必须用<codeph>EXECUTE ON MASTER</codeph>属性定义。否则，在复杂的查询中使用函数时，函数可能返回不正确的结果。
                如果没有该属性，规划器优化可能会将函数调用推送到segment实例中执行。
               </p>
            <p>在创建用户定义的函数时，避免使用致命错误或者破坏性的调用。Greenplum数据库可能会用突然的关闭或者重启来应对这些错误。</p>
            <p>在Greenplum数据库中，用户定义的函数的共享库必须位于Greenplum数据库阵列的所有主机（Master、Segment以及镜像）上的同一库路径地址。</p>
            <p>还可以创建并执行用Greenplum数据库过程语言（例如PL/pgSQL）编写的匿名代码块。匿名块作为短暂的匿名函数运行。有关创建和执行匿名块的信息，请见
 <xref href="../../../ref_guide/sql_commands/DO.xml#topic1"
                        ><codeph>DO</codeph></xref>命令。</p>
        </body>
    </topic>
    <topic id="topic29" xml:lang="en">
        <title id="in141007">内建函数和操作符</title>
        <body>
            <p> 下面的表格列出了PostgreSQL支持的内建函数和操作符的分类。Greenplum数据库中支持PostgreSQL中所有的函数和操作符，除了<codeph>STABLE</codeph>以及<codeph>VOLATILE</codeph>函数之外，这两种服从在Greenplum数据库中使用函数中记录的限制
                <xref format="dita" href="#topic27" type="topic"/>。
                更多有关这些内建函数和操作符的信息请见PostgreSQL文档中的 <xref format="html" href="https://www.postgresql.org/docs/9.4/functions.html"
             scope="external">函数和操作符</xref> 。
               </p>
            <p>Greenplum数据库包括操作<codeph>json</codeph>数据类型值的JSON处理函数。有关JSON数据的信息，请见使用JSON数据 <xref
                    href="json-data.xml#topic1"/>。</p>
            <table id="in204913">
                <title>内建函数和操作符</title>
                <tgroup cols="4">
                    <colspec colname="col1" colnum="1" colwidth="129.02*"/>
                    <colspec colname="col2" colnum="2" colwidth="108*"/>
                    <colspec colname="col3" colnum="3" colwidth="144*"/>
                    <colspec colname="col4" colnum="4" colwidth="86*"/>
                    <thead>
                        <row>
                            <entry colname="col1">操作符/函数分类</entry>
                            <entry colname="col2">VOLATILE函数</entry>
                            <entry colname="col3">STABLE函数</entry>
                            <entry colname="col4">限制</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-logical.html"
                                    scope="external">逻辑操作符</xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-comparison.html"
                                    scope="external">比较操作符</xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-math.html"
                                    scope="external">
                                    <ph>数学函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2">random<p>setseed</p></entry>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-string.html"
                                    scope="external">
                                    <ph>字符串函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2">
                                <i>所有内置转换操作符</i>
                            </entry>
                            <entry colname="col3">convert<p>pg_client_encoding</p></entry>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-binarystring.html"
                                    scope="external">
                                    <ph>二进制串函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-bitstring.html"
                                    scope="external">
                                    <ph>位串函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-matching.html"
                                    scope="external">
                                    <ph>模式匹配</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-formatting.html"
                                    scope="external">
                                    <ph>数据类型格式化函数</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3">to_char<p>to_timestamp</p></entry>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-datetime.html"
                                    scope="external"> 日期/时间函数和操作符</xref>
                            </entry>
                            <entry colname="col2">timeofday</entry>
                            <entry colname="col3"
                                    >age<p>current_date</p><p>current_time</p><p>current_timestamp</p><p>localtime</p><p>localtimestamp</p><p>now</p></entry>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-enum.html"
                                    scope="external">枚举支持函数  </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-geometry.html"
                                    scope="external">
                                    <ph>几何函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-net.html"
                                    scope="external">
                                    <ph>网络地址函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-sequence.html"
                                    scope="external">
                                    <ph>序列操纵函数</ph>
                                </xref>
                            </entry>
                            <entry colname="col2">nextval()<p>setval()</p></entry>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-conditional.html"
                                    scope="external">
                                    <ph>条件表达式</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-array.html"
                                    scope="external">
                                    <ph>数组函数和操作符</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3">
                                <i>所有数组函数</i>
                            </entry>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-aggregate.html"
                                    scope="external">
                                    <ph>聚集函数</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-subquery.html"
                                    scope="external">
                                    <ph>子查询表达式</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-comparisons.html"
                                    scope="external">
                                    <ph>行及数组比较</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-srf.html"
                                    scope="external">
                                    <ph>集合返回函数</ph>
                                </xref>
                            </entry>
                            <entry colname="col2">generate_series</entry>
                            <entry colname="col3"/>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-info.html"
                                    scope="external">
                                    <ph>系统信息函数</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"/>
                            <entry colname="col3">
                                <i>所有会话信息函数</i>
                                <p>
                                    <i>所有访问权限查询函数</i>
                                </p><p>
                                    <i>所有模式可见性查询函数</i>
                                </p><p>
                                    <i>所有系统目录信息函数</i>
                                </p><p>
                                    <i>所有注释信息函数</i>
                                </p><p>
                                    <i>所有事务ID和快照</i>
                                </p></entry>
                            <entry colname="col4"/>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.4/functions-admin.html"
                                    scope="external">
                                    <ph>系统管理函数</ph>
                                </xref>
                            </entry>
                            <entry colname="col2"
                                    >set_config<p>pg_cancel_backend</p><p>pg_terminate_backend</p><p>pg_reload_conf</p><p>pg_rotate_logfile</p><p>pg_start_backup</p><p>pg_stop_backup</p><p>pg_size_pretty</p><p>pg_ls_dir</p><p>pg_read_file</p><p>pg_stat_file</p></entry>
                            <entry colname="col3">current_setting<p><i>所有数据库对象大小
                                        函数</i></p></entry>
                            <entry colname="col4"><b>Note:</b>
                                    <codeph>pg_column_size</codeph> 函数显示存储该值所需的字节，可能使用toast压缩。</entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <xref format="html"
                                    href="https://www.postgresql.org/docs/9.1/functions-xml.html"
                                    scope="external">XML函数</xref>和类似函数的表达式</entry>
                            <entry colname="col2"/>
                            <entry colname="col3">
                                <p>cursor_to_xml(cursor refcursor, count int, nulls boolean,
                                    tableforest boolean, targetns text)</p>
                                <p>cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest
                                    boolean, targetns text)</p>
                                <p>database_to_xml(nulls boolean, tableforest boolean, targetns
                                    text)</p>
                                <p>database_to_xmlschema(nulls boolean, tableforest boolean,
                                    targetns text)</p>
                                <p>database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,
                                    targetns text)</p>
                                <p>query_to_xml(query text, nulls boolean, tableforest boolean,
                                    targetns text)</p>
                                <p>query_to_xmlschema(query text, nulls boolean, tableforest
                                    boolean, targetns text)</p>
                                <p>query_to_xml_and_xmlschema(query text, nulls boolean, tableforest
                                    boolean, targetns text)</p>
                                <p>schema_to_xml(schema name, nulls boolean, tableforest boolean,
                                    targetns text)</p>
                                <p>schema_to_xmlschema(schema name, nulls boolean, tableforest
                                    boolean, targetns text)</p>
                                <p>schema_to_xml_and_xmlschema(schema name, nulls boolean,
                                    tableforest boolean, targetns text)</p>
                                <p>table_to_xml(tbl regclass, nulls boolean, tableforest boolean,
                                    targetns text)</p>
                                <p>table_to_xmlschema(tbl regclass, nulls boolean, tableforest
                                    boolean, targetns text)</p>
                                <p>table_to_xml_and_xmlschema(tbl regclass, nulls boolean,
                                    tableforest boolean, targetns text)</p>
                                <p>xmlagg(xml)</p>
                                <p>xmlconcat(xml[, ...])</p>
                                <p>xmlelement(name name [, xmlattributes(value [AS attname] [, ...
                                    ])] [, content, ...])</p>
                                <p>xmlexists(text, xml)</p>
                                <p>xmlforest(content [AS name] [, ...])</p>
                                <p>xml_is_well_formed(text)</p>
                                <p>xml_is_well_formed_document(text)</p>
                                <p>xml_is_well_formed_content(text)</p>
                                <p>xmlparse ( { DOCUMENT | CONTENT } value)</p>
                                <p>xpath(text, xml)</p>
                                <p>xpath(text, xml, text[])</p>
                                <p>xpath_exists(text, xml)</p>
                                <p>xpath_exists(text, xml, text[])</p>
                                <p>xmlpi(name target [, content])</p>
                                <p>xmlroot(xml, version text | no value [, standalone yes|no|no
                                    value])</p>
                                <p>xmlserialize ( { DOCUMENT | CONTENT } value AS type )</p>
                                <p>xml(text)</p>
                                <p>text(xml)</p>
                                <p>xmlcomment(xml)</p>
                                <p>xmlconcat2(xml, xml)</p>
                            </entry>
                            <entry colname="col4"/>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </body>
    </topic>
    <topic id="topic30" xml:lang="en">
        <title id="in179666">窗口函数</title>
        <body>
            <p>下列内建窗口函数是Greenplum对于PostgreSQL数据库的扩展。所有的窗口函数都是<i>immutable</i>。更多有关窗口函数的信息，请见<xref href="../topics/defining-queries.xml#topic13"/>.</p>
            <table id="in164369">
                <title>窗口函数</title>
                <tgroup cols="4">
                    <colspec colname="col1" colnum="1" colwidth="87.46*"/>
                    <colspec colname="col2" colnum="2" colwidth="59*"/>
                    <colspec colname="col3" colnum="3" colwidth="180*"/>
                    <colspec colname="col4" colnum="4" colwidth="121.77*"/>
                    <thead>
                        <row>
                            <entry colname="col1">函数</entry>
                            <entry colname="col2">返回类型</entry>
                            <entry colname="col3">完整语法</entry>
                            <entry colname="col4">描述</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colname="col1">
                                <codeph>cume_dist()</codeph>
                            </entry>
                            <entry colname="col2">
                                <codeph>double precision</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>CUME_DIST() OVER ( [PARTITION BY </codeph>
                                <ph>expr</ph>
                                <codeph>] ORDER BY </codeph>
                                <ph>expr</ph>
                                <codeph> )</codeph>
                            </entry>
                            <entry colname="col4">计算一组值中一个值的累积分布。具有相等值的行总是具有相同的累积分布值。。
                             </entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>dense_rank()</codeph>
                            </entry>
                            <entry colname="col2">
                                <codeph>bigint</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>DENSE_RANK () OVER ( [PARTITION BY </codeph>
                                <ph>expr</ph>
                                <codeph>] ORDER BY </codeph>
                                <ph>expr</ph>
                                <codeph>)</codeph>
                            </entry>
                            <entry colname="col4">计算一个有序行组中一行的无跳跃排名值的排名。具有相等值的行会得到相同的排名值。
                                </entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>first_value(<i>expr</i>)</codeph>
                            </entry>
                            <entry colname="col2">same as input <ph>expr</ph> type</entry>
                            <entry colname="col3">
                                <codeph>FIRST_VALUE(</codeph>
                                <ph>expr</ph>
                                <codeph>) OVER ( [PARTITION BY </codeph>
                                <ph>expr</ph>
                                <codeph>] ORDER BY </codeph>
                                <ph>expr</ph>
                                <codeph> [ROWS|RANGE </codeph>
                                <ph>frame_expr</ph>
                                <codeph>] )</codeph>
                            </entry>
                            <entry colname="col4">返回一个有续值集合中的第一个值。</entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>lag(<i>expr</i> [,<i>offset</i>] [,<i>default</i>])</codeph>
                            </entry>
                            <entry colname="col2">same as input <i>expr</i> type</entry>
                            <entry colname="col3">
                                <codeph>LAG(</codeph>
                                <i>expr</i>
                                <codeph> [,</codeph>
                                <i>offset</i>
                                <codeph>] [,</codeph>
                                <i>default</i>
                                <codeph>]) OVER ( [PARTITION BY </codeph>
                                <i>expr</i>
                                <codeph>] ORDER BY </codeph>
                                <i>expr</i>
                                <codeph> )</codeph>
                            </entry>
                            <entry
                                    colname="col4">在不做自连接的情况下，提供对于同一个表中多于一行的访问。给定一个查询返回的一系列行以及该游标的一个位置，LAG提供对位于该位置之前一个给定物理偏移量的行的访问。默认的offset为1。
                                default设置当偏移量超出窗口范围之外时要返回的值。如果没有指定default，默认值是空值。
                               </entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>last_value(<i>expr</i></codeph>)</entry>
                            <entry colname="col2">same as input <i>expr</i> type</entry>
                            <entry colname="col3">
                                <codeph>LAST_VALUE(<i>expr</i>) OVER ( [PARTITION BY <i>expr</i>]
                                    ORDER BY <i>expr</i> [ROWS|RANGE <i>frame_expr</i>] )</codeph>
                            </entry>
                            <entry colname="col4">返回一个有序值集合中的最后一个值。</entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>
                                    <codeph>lead(<i>expr</i> [,<i>offset</i>]
                                        [,<i>default</i>])</codeph>
                                </codeph>
                            </entry>
                            <entry colname="col2">same as input <i>expr</i> type</entry>
                            <entry colname="col3">
                                <codeph>LEAD(<i>expr </i>[,<i>offset</i>]
                                        [,<i>expr</i><i>default</i>]) OVER ( [PARTITION BY
                                        <i>expr</i>] ORDER BY <i>expr</i> )</codeph>
                            </entry>
                            <entry colname="col4">
                                在不做自连接的情况下，提供对于同一个表中多于一行的访问。给定一个查询返回的一系列行以及该游标的一个位置，lead提供对位于该位置之后一个给定物理偏移量的行的访问。如果没有指定offset，默认偏移量是1。default设置当偏移量超出窗口范围之外时要返回的值。如果没有指定<i>default</i>，默认值是空值。
                               </entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>ntile(<i>expr</i>)</codeph>
                            </entry>
                            <entry colname="col2"><codeph>bigint</codeph></entry>
                            <entry colname="col3">
                                <codeph>NTILE(<i>expr</i>) OVER ( [PARTITION BY <i>expr</i>] ORDER
                                    BY <i>expr</i> )</codeph>
                            </entry>
                            <entry colname="col4">把一个有序数据集划分成一些桶（由<i>expr</i>)定义）并且为每一行分配一个桶号。
                               </entry>
                        </row>
                        <row>
                            <entry colname="col1"><codeph>percent_rank()</codeph></entry>
                            <entry colname="col2">
                                <codeph>double precision</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>PERCENT_RANK () OVER ( [PARTITION BY <i>expr</i>] ORDER BY
                                        <i>expr </i>)</codeph>
                            </entry>
                            <entry colname="col4">计算一个假设行<codeph>R</codeph>的排名减1，然后除以被计算的行数（在一个窗口分区内）减1。
                               </entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>rank()</codeph>
                            </entry>
                            <entry colname="col2"><codeph>bigint</codeph></entry>
                            <entry colname="col3">
                                <codeph>RANK () OVER ( [PARTITION BY <i>expr</i>] ORDER BY <i>expr
                                    </i>)</codeph>
                            </entry>
                            <entry colname="col4">计算一行在一个有序值组中的排名。根据排名标准有相等值的行得到相同的排名。被占用的行数被加到排名数上来计算下一个排名值。在这种情况下，排名可能不是连续的数字。
                               </entry>
                        </row>
                        <row>
                            <entry colname="col1"><codeph>row_number()</codeph></entry>
                            <entry colname="col2">
                                <codeph>bigint</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>ROW_NUMBER () OVER ( [PARTITION BY <i>expr</i>] ORDER BY
                                        <i>expr </i>)</codeph>
                            </entry>
                            <entry colname="col4">为窗口分区中的每一行或者查询中的每一行分配一个唯一的编号。</entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </body>
    </topic>
    <topic id="topic31" xml:lang="en">
        <title id="in184703">高级聚集函数</title>
        <body>
            <p>下列内建高级聚集函数是Greenplum对PostgreSQL数据库的扩展。这些函数都是<i>immutable</i>。
                Greenplum数据库不支持PostgreSQL有序集聚合函数。
                <note>用于分析的Greenplum MADlib扩展提供了额外的高级函数来执行对Greenplum数据库数据的统计分析和机器学习。
                    请见 <cite>Greenplum数据库参考指南</cite>中的
                    <xref href="../../../ref_guide/extensions/madlib.xml#topic1"
                        >Greenplum的MADlib分析扩展</xref>。</note></p>
            <table id="in2073121">
                <title>高级聚集函数</title>
                <tgroup cols="4">
                    <colspec colname="col1" colnum="1" colwidth="102.44*"/>
                    <colspec colname="col2" colnum="2" colwidth="59*"/>
                    <colspec colname="col3" colnum="3" colwidth="201.99*"/>
                    <colspec colname="col4" colnum="4" colwidth="128*"/>
                    <thead>
                        <row>
                            <entry colname="col1">函数</entry>
                            <entry colname="col2">返回类型</entry>
                            <entry colname="col3">完整语法</entry>
                            <entry colname="col4">描述</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry colname="col1">
                                <codeph>MEDIAN (<i>expr</i>)</codeph>
                            </entry>
                            <entry colname="col2">
                                <codeph>timestamp, timestamptz, interval, float</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>MEDIAN (<i>expression</i>)</codeph>
                                <p>
                                    <i>例子：</i>
                                </p>
                                <codeblock>SELECT department_id, MEDIAN(salary) 
FROM employees 
GROUP BY department_id; </codeblock>
                            </entry>
                            <entry colname="col4">可以用一个二维数组作为输入。把这些数组当作矩阵。</entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>sum(array[])</codeph>
                            </entry>
                            <entry colname="col2">
                                <codeph>smallint[]int[], bigint[], float[]</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>sum(array[[1,2],[3,4]])</codeph>
                                <p>
                                    <i>例子：</i>
                                </p>
                                <codeblock>CREATE TABLE mymatrix (myvalue int[]);
INSERT INTO mymatrix VALUES (array[[1,2],[3,4]]);
INSERT INTO mymatrix VALUES (array[[0,1],[1,0]]);
SELECT sum(myvalue) FROM mymatrix;
 sum 
---------------
 {{1,3},{4,4}}</codeblock>
                            </entry>
                            <entry colname="col4">执行矩阵求和。可以将被视为矩阵的二维数组作为输入。</entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>pivot_sum (label[], label, expr)</codeph>
                            </entry>
                            <entry colname="col2">
                                <codeph>int[], bigint[], float[]</codeph>
                            </entry>
                            <entry colname="col3">
                                <codeph>pivot_sum( array['A1','A2'], attr, value)</codeph>
                            </entry>
                            <entry colname="col4">使用sum来解决重复项的pivot聚集。</entry>
                        </row>
                        <row>
                            <entry colname="col1">
                                <codeph>unnest (array[])</codeph>
                            </entry>
                            <entry colname="col2"><codeph>anyelement</codeph>集合</entry>
                            <entry colname="col3">
                                <codeph>unnest( array['one', 'row', 'per', 'item'])</codeph>
                            </entry>
                            <entry colname="col4">把一个一维数组转换成行。返回一个anyelement（一种多态伪类型，请见PostgreSQL中的伪类型）集合。<xref
                                    format="html"
                                    href="https://www.postgresql.org/docs/9.4/datatype-pseudo.html"
                                    scope="external"><ph>pseudo-type</ph></xref> </entry>
                        </row>
                    </tbody>
                </tgroup>
            </table>
        </body>
    </topic>
</topic>
