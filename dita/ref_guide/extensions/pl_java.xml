<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="pv161085">Greenplum的PL/Java语言扩展</title>
  <body>
    <p>本节包含Greenplum数据库的PL/Java语言的概述。</p>
    <ul>
      <li id="pv161174">
        <xref href="#topic2" type="topic" format="dita"/>
      </li>
      <li id="pv161261">
        <xref href="#topic10" type="topic" format="dita"/>
      </li>
      <li id="pv161280" otherprops="pivotal">
        <xref href="#topic4" type="topic" format="dita"/>
      </li>
      <li otherprops="pivotal">
        <xref href="#topic6" format="dita"/></li>
      <li otherprops="pivotal">
        <xref href="#topic7" format="dita"/></li>
      <li id="pv161254">
        <xref href="#topic13" type="topic" format="dita"/>
      </li>
      <li id="pv165944">
        <xref href="#topic24" type="topic" format="dita"/>
      </li>
      <li id="pv165963">
        <xref href="#topic25" type="topic" format="dita"/>
      </li>
      <li id="pv165978">
        <xref href="#topic26" type="topic" format="dita"/>
      </li>
      <li id="pv165997">
        <xref href="#topic27" type="topic" format="dita"/>
      </li>
      <li id="pv166027">
        <xref href="#topic28" type="topic" format="dita"/>
      </li>
      <li id="pv166042">
        <xref href="#topic33" type="topic" format="dita"/>
      </li>
      <li id="pv161247">
        <xref href="#topic40" type="topic" format="dita"/>
      </li>
      <li id="pv161240">
        <xref href="#topic41" type="topic" format="dita"/>
      </li>
    </ul>
  </body>
  <topic id="topic2" xml:lang="en">
    <title id="pv161093">关于PL/Java</title>
    <body>
      <p>使用Greenplum数据库的PL/Java扩展，用户可以使用自己喜欢的Java IDE编写Java方法，并将包含这些方法的JAR文件安装到Greenplum数据库中。</p>
      <p>Greenplum数据库的PL/Java包基于开源PL/Java 1.5.0。
        Greenplum数据库的PL/Java提供以下功能。
        </p>
      <ul>
        <li id="pv161029">能够使用Java 8或Java 11执行PL/Java函数。</li>
        <li>能够指定Java运行时。</li>
        <li id="pv161030">在数据库中安装和维护Java代码的标准化实用程序（在SQL 2003提案之后设计）
          </li>
        <li id="pv161031">参数和结果的标准化映射。支持复杂类型和集合。
          </li>
        <li id="pv161032">使用Greenplum数据库内部SPI例程的嵌入式高性能JDBC驱动程序。
          </li>
        <li id="pv161033">元数据支持JDBC驱动程序。
          包括<codeph>DatabaseMetaData</codeph>和<codeph>ResultSetMetaData</codeph>。
          </li>
        <li id="pv161034">能够从查询中返回ResultSet，作为逐行构建ResultSet的替代方法。
          </li>
        <li id="pv161035">完全支持保存点和异常处理。</li>
        <li id="pv161036">能够使用IN，INPUT和OUT参数。</li>
        <li id="pv161037">两种独立的Greenplum数据库语言:<ul id="ul_rl4_vc5_lv">
            <li>pljava, TRUSTED PL/Java language</li>
            <li>pljavau, UNTRUSTED PL/Java language</li>
          </ul></li>
        <li id="pv161038">当一个事务或者保存点提交或者回滚时，事务和保存点监听器能够被编译执行。
          </li>
        <li id="pv161039">在所选平台上与GNU GCJ集成。</li>
      </ul>
      <p>SQL中的一个函数将在Java类中指定一个静态方法。
        为了使函数能够执行，所指定的类必须能够通过Greenplum数据库服务器上的<codeph>pljava_classpath</codeph>配置参数来指定类路径。
        PL/Java扩展添加了一组有助于安装和维护java类的函数。
        类存储在普通的Java档案——JAR文件中。
        JAR文件可以选择性地包含部署描述符，该描述符又包含在部署或取消部署JAR时要执行的SQL命令。
        这些函数是按照SQL 2003提出的标准进行设计的。
        </p>
      <p>PL/Java实现了传递参数和返回值的标准化方法。
        使用标准JDBC ResultSet类传递复杂类型和集合。
        </p>
      <p>PL/Java中包含JDBC驱动程序。
        此驱动程序调用Greenplum数据库内部SPI例程。
        驱动程序是必不可少的，因为函数通常将调用数据库以获取数据。
        当PL/Java函数提取数据时，它们必须使用与输入PL/Java执行上下文的主函数使用的相同的事务边界。
        </p>
      <p>PL/Java针对性能进行了优化。
        Java虚拟机在与后端相同的进程中执行，以最小化调用开销。
        PL/Java的设计目的是为了使数据库本身能够实现Java的强大功能，以便数据库密集型业务逻辑可以尽可能靠近实际数据执行。
        </p>
      <p>当后端和Java VM之间的桥梁被调用时，将使用标准Java本机接口（JNI）。
        </p>
    </body>
  </topic>
  <topic id="topic10" xml:lang="en">
    <title id="pv159836">关于Greenplum数据库PL/Java</title>
    <body>
      <p>在标准PostgreSQL和Greenplum数据库中实现PL/Java有一些关键的区别。
        </p>
    </body>
    <topic id="topic11" xml:lang="en">
      <title>函数</title>
      <body>
        <p>以下函数在Greenplum数据库中不被支持。
          在分布式的Greenplum数据库环境中，classpath的处理方式与PostgreSQL环境下不同。
          <sl>
            <sli><codeph>sqlj.install_jar</codeph>
            </sli>
            <sli><codeph>sqlj.replace_jar</codeph>
            </sli>
            <sli><codeph>sqlj.remove_jar</codeph></sli>
            <sli><codeph>sqlj.get_classpath</codeph></sli>
            <sli><codeph>sqlj.set_classpath</codeph></sli>
          </sl></p>
        <p>Greenplum数据库使用<codeph>pljava_classpath</codeph>服务器配置参数代替<codeph>sqlj.set_classpath</codeph>函数。
          </p>
      </body>
    </topic>
    <topic id="topic12" xml:lang="en">
      <title>服务器配置参数</title>
      <body>
        <p>以下服务器配置参数由PL/Java在Greenplum数据库中使用。
          这些参数取代了标准PostgreSQL PL/Java实现中使用的<codeph>pljava.*</codeph>参数：
          </p>
        <ul id="ul_ksz_5r5_b1b">
          <li id="pv159849">
            <codeph>pljava_classpath</codeph>
            <p>冒号(<codeph>:</codeph>)分隔的包含任何PL/Java函数中使用的Java类的jar文件列表。
              所有的jar文件必须安装在所有的Greenplum数据库主机的相同位置。
              使用可信的PL/Java语言处理程序，jar文件路径必须相对于<codeph>$GPHOME/lib/postgresql/java/</codeph>目录。
              使用不受信任的语言处理程序（javaU语言标记），路径可以相对于<codeph>$GPHOME/lib/postgresql/java/</codeph>或使用绝对路径。
              </p>
            <p>服务器配置参数<codeph>pljava_classpath_insecure</codeph>控制服务器配置参数<codeph>pljava_classpath</codeph>是否可以由用户设置，
              无需Greenplum数据库超级用户权限。
              当启用<codeph>pljava_classpath_insecure</codeph>时，
              正在开发PL/Java函数的Greenplum数据库开发人员不必是数据库超级用户身份才能来更改<codeph>pljava_classpath</codeph>。
              </p>
            <note type="warning">启用<codeph>pljava_classpath_insecure</codeph>通过为非管理员数据库用户提供能够运行未经授权的Java方法暴露了安全风险。
              </note></li>
          <li id="pv159853">
            <codeph>pljava_statement_cache_size</codeph>
            <p>为准备语句设置最近使用（MRU）缓存的大小（KB）。</p>
            </li>
          <li id="pv159856">
            <codeph>pljava_release_lingering_savepoints</codeph>
            <p>如果为<codeph>TRUE</codeph>，在函数退出后，长期持续的保存点将会释放。
              如果为<codeph>FALSE</codeph>，它们将被回滚。
              </p></li>
          <li id="pv159859">
            <codeph>pljava_vmoptions</codeph>
            <p>定义Greenplum数据库Java VM的启动选项。</p></li>
        </ul>
        <p>参阅<cite>Greenplum数据库参考指南</cite>有关Greenplum数据库服务器配置参数的信息。
          </p>
      </body>
    </topic>
  </topic>
  <topic id="topic4" xml:lang="en" otherprops="pivotal">
    <title id="pv158223">Installing PL/Java</title>
    <body>
      <p>For Greenplum Database, the PL/Java extension is available as a package. Download the
        package from the Greenplum Database page on <xref
          href="https://network.pivotal.io/products/pivotal-gpdb" scope="external" format="html"
          class="- topic/xref ">Pivotal Network</xref> and then install it with the Greenplum
        Package Manager (<codeph>gppkg</codeph>). </p>
      <p>The <codeph>gppkg</codeph> utility installs Greenplum Database extensions, along with any
        dependencies, on all hosts across a cluster. It also automatically installs extensions on
        new hosts in the case of system expansion and segment recovery.</p>
      <p>For information about <codeph>gppkg,</codeph>see the <cite>Greenplum Database Utility
          Guide</cite>.</p>
      <note type="important">PL/Java requires a Java environment on each Greenplum Database host.
        Ensure that the same Java environment is at the same location on all hosts: masters and
        segments. For example, to install OpenJDK
        11:<codeblock>$ yum install -y java-11-openjdk</codeblock></note>
      <p>To install and use PL/Java:</p>
      <ol>
        <li>Specify the Java version used by PL/Java. Set the environment variables
            <codeph>JAVA_HOME</codeph> and <codeph>LD_LIBRARY_PATH</codeph> in the
            <codeph>greenplum_path.sh</codeph>.</li>
        <li id="pv158542">Install the Greenplum Database PL/Java extension. </li>
        <li id="pv158366">Enable the language for each database where you intend to use
          PL/Java.</li>
        <li id="pv158382">Install user-created JAR files containing Java methods into the same
          directory on all Greenplum Database hosts.</li>
        <li id="pv158391">Add the name of the JAR file to the Greenplum Database server
          configuration parameter <codeph>pljava_classpath</codeph>. The parameter lists the
          installed JAR files. For information about the parameter, see the <cite>Greenplum Database
            Reference Guide</cite>.</li>
      </ol>
    </body>
    <topic id="topic5" xml:lang="en">
      <title>Installing the Greenplum PL/Java Extension</title>
      <body>
        <p>Before you install the PL/Java extension, make sure that your Greenplum database is
          running, you have sourced <codeph>greenplum_path.sh</codeph>, and that the
            <codeph>$MASTER_DATA_DIRECTORY</codeph> and <codeph>$GPHOME</codeph> variables are
          set.</p>
        <ol>
          <li id="pv158485">Download the PL/Java extension package from the Greenplum Database page
            on <xref href="https://network.pivotal.io/products/pivotal-gpdb" scope="external"
              format="html" class="- topic/xref ">Pivotal Network</xref> then copy it to the master
            host. </li>
          <li id="pv160918">Install the software extension package by running the
              <codeph>gppkg</codeph> command. This example installs the PL/Java extension package on
            a Linux
            system:<codeblock>$ gppkg -i pljava-1.4.3-gp5-rhel<varname>osversion</varname>-x86_64.gppkg</codeblock></li>
          <li>Ensure that the environment variables <codeph>JAVA_HOME</codeph> and
              <codeph>LD_LIBRARY_PATH</codeph> are set properly in
              <codeph>$GPHOME/greenplum_path.sh</codeph> on all Greenplum Database hosts.<ul
              id="ul_mgq_wgh_qw">
              <li>Set the <codeph>JAVA_HOME</codeph> variable to the directory where your Java
                Runtime is installed. For example, for Oracle JRE this directory would be
                  <codeph>/usr/java/latest</codeph>. For OpenJDK, the directory is
                  <codeph>/usr/lib/jvm</codeph>. This example changes the environment variable
                to use
                <codeph>/usr/lib/jvm</codeph>.<codeblock>JAVA_HOME=/usr/lib/jvm</codeblock></li>
              <li>Set the <codeph>LD_LIBRARY_PATH</codeph> to include the directory with the Java
                server runtime libraries. PL/Java depends on <codeph>libjvm.so</codeph> and the
                shared object should be in your <codeph>LD_LIBRARY_PATH</codeph>. By default,
                  <codeph>libjvm.so</codeph> is available in <codeph>$JAVA_HOME/lib/server</codeph>
                with JDK 11, or in <codeph>$JAVA_HOME/jre/lib/amd64/server</codeph> with JDK 8. This
                example adds the JDK 11 directory to the environment
                variable.<codeblock>LD_LIBRARY_PATH=$GPHOME/lib:$GPHOME/ext/python/lib:<b>$JAVA_HOME/lib/server</b>:$LD_LIBRARY_PATH</codeblock></li>
            </ul>This example <codeph>gpscp</codeph> command copies the file to all hosts specified
            in the file
            <codeph>gphosts_file</codeph>.<codeblock>$ gpscp -f gphosts_file $GPHOME/greenplum_path.sh 
=:$GPHOME/greenplum_path.sh</codeblock></li>
          <li dir="ltr">Reload
            <codeph>greenplum_path.sh</codeph>.<codeblock dir="ltr">$ source $GPHOME/greenplum_path.sh</codeblock></li>
          <li id="pv162228">Restart Greenplum Database.<codeblock>$ gpstop -r</codeblock></li>
        </ol>
      </body>
    </topic>
  </topic>
  <topic id="topic6" xml:lang="en">
    <title id="pv161784">启用PL/Java并安装JAR文件</title>
    <body>
      <p>以Greenplum数据库管理员<codeph>gpadmin</codeph>的身份执行以下步骤。
        </p>
      <ol id="ol_dpn_qr5_b1b">
        <li id="pv162268">通过执行<codeph>CREATE EXTENSION</codeph>命令注册语言，以在数据库中启用PL/Java。
          例如，此命令在<codeph>testdb</codeph>数据库中启用PL/Java：
          <codeblock>$ psql -d testdb -c 'CREATE EXTENSION pljava;'</codeblock>
          <note>不推荐使用PL/Java <codeph>install.sql</codeph>脚本（在以前的版本中用于注册该语言）。
            </note></li>
        <li id="pv160325">将Java归档（JAR文件）复制到所有Greenplum数据库主机上的同一目录。
          本示例使用Greenplum数据库<codeph>gpscp</codeph>程序将文件<codeph>myclasses.jar</codeph>复制到目录<codeph>$GPHOME/lib/postgresql/java/</codeph>:
          <codeblock>$ gpscp -f gphosts_file myclasses.jar
=:/usr/local/greenplum-db/lib/postgresql/java/</codeblock>
          <p>文件<codeph>gphosts_file</codeph>包含一个Greenplum数据库主机的列表。
            </p></li>
        <li id="pv160327">设置<codeph>pljava_classpath</codeph>服务器配置参数在master的<codeph>postgresql.conf</codeph>文件中。
          对于此示例，参数值是冒号(:)分隔的JAR文件列表。例如：
          <codeblock>$ gpconfig -c pljava_classpath -v 'examples.jar:myclasses.jar'</codeblock>
          <p>当用户使用<codeph>gppkg</codeph>实用程序安装PL/Java扩展包时，将安装<codeph>examples.jar</codeph>文件。
            </p>
          <note>如果将JAR文件安装在除<codeph>$GPHOME/lib/postgresql/java/</codeph>之外的目录中，则必须指定JAR文件的绝对路径。
            所有的Greenplum数据库主机上的每个JAR文件必须位于相同的位置。
            有关指定JAR文件位置的更多信息，参阅<cite>Greenplum数据库参考指南</cite>中的<codeph>pljava_classpath</codeph>服务器配置参数。
            </note></li>
        <li id="pv160329">重新加载<codeph>postgresql.conf</codeph>文件。
          <codeblock>$ gpstop -u</codeblock></li>
        <li id="pv160335">(可选)Greenplum提供了一个包含可用于测试的示例PL/Java函数的<codeph>examples.sql</codeph>文件。
          运行此文件中的命令来创建测试函数 (它使用<codeph>examples.jar</codeph>中的Java类)。
          <codeblock>$ psql -f $GPHOME/share/postgresql/pljava/examples.sql</codeblock></li>
      </ol>
    </body>
  </topic>
  <topic id="topic7" xml:lang="en" otherprops="pivotal">
    <title>Uninstalling PL/Java</title>
    <body>
      <ul id="ul_zsz_fs5_b1b">
        <li id="pv165655"><xref href="#topic8" type="topic" format="dita"/>
        </li>
        <li id="pv165686"><xref href="#topic9" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic8" xml:lang="en">
      <title id="pv165472">Remove PL/Java Support for a Database</title>
      <body>
        <p>Use the <codeph>DROP EXTENSION</codeph> command to remove support for PL/Java from a
          database. For example, this command disables the PL/Java language in the
            <codeph>testdb</codeph> database: </p>
        <codeblock>$ psql -d testdb -c 'DROP EXTENSION pljava;'</codeblock>
        <p> The default command fails if any existing objects (such as functions) depend on the
          language. Specify the <codeph>CASCADE</codeph> option to also drop all dependent objects,
          including functions that you created with PL/Java. </p>
        <note>The PL/Java <codeph>uninstall.sql</codeph> script, used in previous releases to remove
          the language registration, is deprecated.</note>
      </body>
    </topic>
    <topic id="topic9" xml:lang="en">
      <title id="pv165506">Uninstall the Java JAR files and Software Package</title>
      <body>
        <p>If no databases have PL/Java as a registered language, remove the Java JAR files and
          uninstall the Greenplum PL/Java extension with the <codeph>gppkg</codeph> utility. </p>
        <ol id="ol_atz_fs5_b1b">
          <li id="pv165538">Remove the <codeph>pljava_classpath</codeph> server configuration
            parameter from the <codeph>postgresql.conf</codeph> file on all Greenplum Database
            hosts. For example:<codeblock>$ gpconfig -r pljava_classpath</codeblock></li>
          <li id="pv165539">Remove the JAR files from the directories where they were installed on
            all Greenplum Database hosts. For information about JAR file installation directories,
            see <xref href="#topic6" format="dita"/>.</li>
          <li id="pv160641">Use the Greenplum <codeph>gppkg</codeph> utility with the
              <codeph>-r</codeph> option to uninstall the PL/Java extension. This example uninstalls
            the PL/Java extension on a Linux
              system:<codeblock>$ gppkg -r pljava-1.4.3</codeblock><p>You can run the
                <codeph>gppkg</codeph> utility with the options <codeph>-q --all</codeph> to list
              the installed extensions and their versions.</p></li>
          <li dir="ltr">Reload
            <codeph>greenplum_path.sh</codeph>.<codeblock dir="ltr">$ source $GPHOME/greenplum_path.sh</codeblock></li>
          <li id="pv158621">Restart the database.<codeblock>$ gpstop -r </codeblock></li>
        </ol>
      </body>
    </topic>
  </topic>
  <topic id="topic13" xml:lang="en">
    <title id="pv158066">编写PL/Java函数</title>
    <body>
      <p>有关使用PL/Java编写函数的信息。</p>
      <ul>
        <li id="pv164880">
          <xref href="#topic14" type="topic" format="dita"/>
        </li>
        <li id="pv164915">
          <xref href="#topic15" type="topic" format="dita"/>
        </li>
        <li id="pv164922">
          <xref href="#topic16" type="topic" format="dita"/>
        </li>
        <li id="pv164929">
          <xref href="#topic17" type="topic" format="dita"/>
        </li>
        <li id="pv164936">
          <xref href="#topic18" type="topic" format="dita"/>
        </li>
        <li id="pv164947">
          <xref href="#topic18" type="topic" format="dita"/>
        </li>
        <li id="pv164954">
          <xref href="#topic19" type="topic" format="dita"/>
        </li>
        <li id="pv164961">
          <xref href="#topic20" type="topic" format="dita"/>
        </li>
        <li id="pv164995">
          <xref href="#topic21" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic14" xml:lang="en">
      <title id="pv164882">SQL声明</title>
      <body>
        <p>一个Java函数被声明为该类的一个类名称和静态方法。
          该类将用于为该函数声明的schema定义的classpath进行解析。
          如果没有为该schema定义classpath，则使用public schema。
          如果没有找到classpath，则使用系统类加载器解析该类。
          </p>
        <p>可以声明以下函数来访问<codeph>java.lang.System</codeph>类上的静态方法<codeph>getProperty</codeph>：
          </p>
        <codeblock>CREATE FUNCTION getsysprop(VARCHAR)
  RETURNS VARCHAR
  AS 'java.lang.System.getProperty'
  LANGUAGE java;</codeblock>
        <p>运行以下命令返回Jave <codeph>user.home</codeph>属性:
          </p>
        <codeblock>SELECT getsysprop('user.home');</codeblock>
      </body>
    </topic>
    <topic id="topic15" xml:lang="en">
      <title id="pv157321">类型映射</title>
      <body>
        <p>标量类型以简单的方式映射。此表列出了当前的映射。</p>
        <table id="pv157323">
          <title>PL/Java数据类型映射</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="col1" colwidth="110pt"/>
            <colspec colnum="2" colname="col2" colwidth="165pt"/>
            <thead>
              <row>
                <entry colname="col1">PostgreSQL</entry>
                <entry colname="col2">Java</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="col1">bool</entry>
                <entry colname="col2">boolean</entry>
              </row>
              <row>
                <entry colname="col1">char</entry>
                <entry colname="col2">byte</entry>
              </row>
              <row>
                <entry colname="col1">int2</entry>
                <entry colname="col2">short</entry>
              </row>
              <row>
                <entry colname="col1">int4</entry>
                <entry colname="col2">int</entry>
              </row>
              <row>
                <entry colname="col1">int8</entry>
                <entry colname="col2">long</entry>
              </row>
              <row>
                <entry colname="col1">varchar</entry>
                <entry colname="col2"> java.lang.String</entry>
              </row>
              <row>
                <entry colname="col1">text</entry>
                <entry colname="col2"> java.lang.String</entry>
              </row>
              <row>
                <entry colname="col1">bytea</entry>
                <entry colname="col2">byte[ ]</entry>
              </row>
              <row>
                <entry colname="col1">date</entry>
                <entry colname="col2">java.sql.Date</entry>
              </row>
              <row>
                <entry colname="col1">time</entry>
                <entry colname="col2">java.sql.Time (stored value treated as local time)</entry>
              </row>
              <row>
                <entry colname="col1">timetz</entry>
                <entry colname="col2">java.sql.Time</entry>
              </row>
              <row>
                <entry colname="col1">timestamp</entry>
                <entry colname="col2">java.sql.Timestamp (stored value treated as local
                  time)</entry>
              </row>
              <row>
                <entry colname="col1">timestamptz</entry>
                <entry colname="col2">java.sql.Timestamp</entry>
              </row>
              <row>
                <entry colname="col1">complex</entry>
                <entry colname="col2">java.sql.ResultSet</entry>
              </row>
              <row>
                <entry colname="col1">setof complex</entry>
                <entry colname="col2">java.sql.ResultSet</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p>所有其他类型都映射到java.lang.String，
          并将使用为各自类型注册的标准<codeph>textin</codeph>/<codeph>textout</codeph>例程。
          </p>
      </body>
    </topic>
    <topic id="topic16" xml:lang="en">
      <title id="pv157393">NULL处理</title>
      <body>
        <p>映射到java基元的标量类型不能作为<codeph>NULL</codeph>值传递。
          要传递<codeph>NULL</codeph>值, 这些类型可以有一个替代映射。
          用户可以通过在方法引用中明确的指定该映射来启用映射。
          </p>
        <codeblock>CREATE FUNCTION trueIfEvenOrNull(integer)
  RETURNS bool
  AS 'foo.fee.Fum.trueIfEvenOrNull(java.lang.Integer)'
  LANGUAGE java;</codeblock>
        <p>Java代码将类似于：</p>
        <codeblock>package foo.fee;
public class Fum
{
  static boolean trueIfEvenOrNull(Integer value)
  {
    return (value == null)
      ? true
      : (value.intValue() % 2) == 0;
  }
}</codeblock>
        <p>以下两个语句都产生true：</p>
        <codeblock>SELECT trueIfEvenOrNull(NULL);
SELECT trueIfEvenOrNull(4);</codeblock>
        <p>为了从Java方法返回<codeph>NULL</codeph>值,
          可以使用与原始对象相对应的对象类型 (例如，返回<codeph>java.lang.Integer</codeph>而不是<codeph>int</codeph>)。
          PL/Java解析机制无论如何都会找到该方法。
          由于Java对于具有相同名称的方法不能具有不同的返回类型，因此不会引入任何歧义。
          </p>
      </body>
    </topic>
    <topic id="topic17" xml:lang="en">
      <title id="pv157414">复杂类型</title>
      <body>
        <p>复杂类型将始终作为只读的<codeph>java.sql.ResultSet</codeph>传递，只有一行。
          ResultSet位于其行上，因此不应该调用<codeph>next()</codeph>。
          使用ResultSet的标准getter方法检索复杂类型的值。
          </p>
        <p>例如:</p>
        <codeblock>CREATE TYPE complexTest
  AS(base integer, incbase integer, ctime timestamptz);
CREATE FUNCTION useComplexTest(complexTest)
  RETURNS VARCHAR
  AS 'foo.fee.Fum.useComplexTest'
  IMMUTABLE LANGUAGE java;</codeblock>
        <p>在java类<codeph>Fum</codeph>中，我们添加以下静态方法：</p>
        <codeblock>public static String useComplexTest(ResultSet complexTest)
throws SQLException
{
  int base = complexTest.getInt(1);
  int incbase = complexTest.getInt(2);
  Timestamp ctime = complexTest.getTimestamp(3);
  return "Base = \"" + base +
    "\", incbase = \"" + incbase +
    "\", ctime = \"" + ctime + "\"";
}</codeblock>
      </body>
    </topic>
    <topic id="topic18" xml:lang="en">
      <title id="pv157435">返回复杂类型</title>
      <body>
        <p>Java没有规定任何创建ResultSet的方法。
          因此，返回ResultSet不是一个选项。
          SQL-2003草案建议将复杂的返回值作为IN/OUT参数处理。
          PL/Java以这种方式实现了一个ResultSet。
          如果用户声明一个返回复杂类型的函数，则需要使用带有最后一个参数类型为<codeph>java.sql.ResultSet</codeph>的布尔返回类型的Java方法。
          该参数将被初始化为一个空的可更新结果集，它只包含一行。
          </p>
        <p>假设已经创建了上一节中的<codeph>complexTest</codeph>类型。
          </p>
        <codeblock>CREATE FUNCTION createComplexTest(int, int)
  RETURNS complexTest
  AS 'foo.fee.Fum.createComplexTest'
  IMMUTABLE LANGUAGE java;</codeblock>
        <p>PL/Java方法解析现在将在<codeph>Fum</codeph>类中找到以下方法：
          </p>
        <codeblock>public static boolean complexReturn(int base, int increment, 
  ResultSet receiver)
throws SQLException
{
  receiver.updateInt(1, base);
  receiver.updateInt(2, base + increment);
  receiver.updateTimestamp(3, new 
    Timestamp(System.currentTimeMillis()));
  return true;
}</codeblock>
        <p>返回值表示接收方是否应被视为有效的元组（true）或NULL（false）。
          </p>
      </body>
    </topic>
    <topic id="topic19" xml:lang="en">
      <title id="pv165879">返回集的函数</title>
      <body>
        <p>返回结果集时，不要在返回结果集之前构建结果集，因为构建大型结果集将消耗大量资源。
          最好一次产生一行。
          顺便提一句，那就是Greenplum数据库后端期望一个使用SETOF返回的函数。
          那用户就可以返回SETOF的一个标量类型，
          如<codeph>int</codeph>, <codeph>float</codeph>或<codeph>varchar</codeph>或者可以返回一个复合类型的SETOF。
          </p>
      </body>
    </topic>
    <topic id="topic20" xml:lang="en">
      <title id="pv157454">返回SETOF&lt;标量类型></title>
      <body>
        <p>为了返回一组标量类型，用户需要创建一个实现<codeph>java.util.Iterator</codeph>接口的Java方法。
          这是一个返回一个SETOF的<codeph>varchar</codeph>的方法的例子:
          </p>
        <codeblock>CREATE FUNCTION javatest.getSystemProperties()
  RETURNS SETOF varchar
  AS 'foo.fee.Bar.getNames'
  IMMUTABLE LANGUAGE java;</codeblock>
        <p>这个简单的Java方法返回一个迭代器:</p>
        <codeblock>package foo.fee;
import java.util.Iterator;

public class Bar
{
    public static Iterator getNames()
    {
        ArrayList names = new ArrayList();
        names.add("Lisa");
        names.add("Bob");
        names.add("Bill");
        names.add("Sally");
        return names.iterator();
    }
}</codeblock>
      </body>
    </topic>
    <topic id="topic21" xml:lang="en">
      <title id="pv157476">返回SETOF&lt;复杂类型></title>
      <body>
        <p>返回SETOF&lt;复杂类型>的方法必须使用接口<codeph>org.postgresql.pljava.ResultSetProvider</codeph>或<codeph>org.postgresql.pljava.ResultSetHandle</codeph>。
          具有两个接口的原因是它们满足两种不同用例的最佳处理。
          前者适用于要动态创建要从SETOF函数返回的每一行的情况。
          在用户要返回执行查询的结果的情况下，后者将生成。
        </p>
      </body>
      <topic id="topic22" xml:lang="en">
        <title>使用ResultSetProvider接口</title>
        <body>
          <p>该接口有两种方法。
            布尔型<codeph>assignRowValues(java.sql.ResultSet tupleBuilder, int rowNumber)</codeph>和<codeph>void close()</codeph>方法。
            Greenplum数据库的查询执行器将重复调用<codeph>assignRowValues</codeph>直到它返回假或者直到执行器决定不需要更多行为止。
            然后它会调用close。
            </p>
          <p>用户可以通过以下方式使用此接口：</p>
          <codeblock>CREATE FUNCTION javatest.listComplexTests(int, int)
  RETURNS SETOF complexTest
  AS 'foo.fee.Fum.listComplexTest'
  IMMUTABLE LANGUAGE java;</codeblock>
          <p>该函数映射到一个返回实现<codeph>ResultSetProvider</codeph>接口实例的静态java方法。
            </p>
          <codeblock>public class Fum implements ResultSetProvider
{
  private final int m_base;
  private final int m_increment;
  public Fum(int base, int increment)
  {
    m_base = base;
    m_increment = increment;
  }
  public boolean assignRowValues(ResultSet receiver, int 
currentRow)
  throws SQLException
  {
    // Stop when we reach 12 rows.
    //
    if(currentRow &gt;= 12)
      return false;
    receiver.updateInt(1, m_base);
    receiver.updateInt(2, m_base + m_increment * currentRow);
    receiver.updateTimestamp(3, new 
Timestamp(System.currentTimeMillis()));
    return true;
  }
  public void close()
  {
   // Nothing needed in this example
  }
  public static ResultSetProvider listComplexTests(int base, 
int increment)
  throws SQLException
  {
    return new Fum(base, increment);
  }
}</codeblock>
          <p><codeph>listComplextTests</codeph>方法被调用一次。
            如果没有可用结果或<codeph>ResultSetProvider</codeph>实例，将返回<codeph>NULL</codeph>。
            这里的Java类<codeph>Fum</codeph>实现了这个接口，所以它返回一个自己的实例。
            然后将重复调用<codeph>assignRowValues</codeph>方法，直到返回false。
            到那候，将会调用close。
            </p>
        </body>
      </topic>
      <topic id="topic23" xml:lang="en">
        <title>使用ResultSetHandle接口</title>
        <body>
          <p>该接口类似于<codeph>ResultSetProvider</codeph>接口因为它也有将在最后调用的<codeph>close()</codeph>方法。
            但是，不是让evaluator调用一次构建一行的方法，而是返回一个ResultSet的方法。
            查询evaluator将遍历该集合，并将RestulSet内容一次一个元组传递给调用者，直到对<codeph>next()</codeph>的调用返回false或者evaluator决定不需要更多行。
            </p>
          <p>这是一个使用默认连接获取的语句执行查询的示例。
            适用于部署描述符的SQL看起来像这样:
            </p>
          <codeblock>CREATE FUNCTION javatest.listSupers()
  RETURNS SETOF pg_user
  AS 'org.postgresql.pljava.example.Users.listSupers'
  LANGUAGE java;
CREATE FUNCTION javatest.listNonSupers()
  RETURNS SETOF pg_user
  AS 'org.postgresql.pljava.example.Users.listNonSupers'
  LANGUAGE java;</codeblock>
          <p>并且在Java包<codeph>org.postgresql.pljava.example</codeph>中加入了一个<codeph>Users</codeph>类：
            </p>
          <codeblock>public class Users implements ResultSetHandle
{
  private final String m_filter;
  private Statement m_statement;
  public Users(String filter)
  {
    m_filter = filter;
  }
  public ResultSet getResultSet()
  throws SQLException
  {
    m_statement = 
      DriverManager.getConnection("jdbc:default:connection").cr
eateStatement();
    return m_statement.executeQuery("SELECT * FROM pg_user 
       WHERE " + m_filter);
  }

  public void close()
  throws SQLException
  {
    m_statement.close();
  }

  public static ResultSetHandle listSupers()
  {
    return new Users("usesuper = true");
  }

  public static ResultSetHandle listNonSupers()
  {
    return new Users("usesuper = false");
  }
}</codeblock>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic24" xml:lang="en">
    <title id="pv157564">使用JDBC</title>
    <body>
      <p>PL/Java包含映射到PostgreSQL SPI函数的JDBC驱动程序。
        可以使用以下语句获取映射到当前事务的连接：
        </p>
      <codeblock>Connection conn = 
  DriverManager.getConnection("jdbc:default:connection"); </codeblock>
      <p>获取连接后，可以准备和执行类似于其他JDBC连接的语句。
        这些是PL/Java JDBC驱动程序的限制:
        </p>
      <ul>
        <li id="pv157568">事务无法以任何方式进行管理。因此，连接后用户不能用如下方法:
          <ul id="ul_yxm_d3c_lp">
            <li id="pv157569"><codeph>commit()</codeph></li>
            <li id="pv157570"><codeph>rollback()</codeph></li>
            <li id="pv157571"><codeph>setAutoCommit()</codeph></li>
            <li id="pv157572"><codeph>setTransactionIsolation()</codeph></li>
          </ul></li>
        <li id="pv157573">在保存点上也有一些限制。
          保存点不能超过其设置的功能，并且必须由同一功能回滚或释放。
          </li>
        <li id="pv157574">从<codeph>executeQuery()</codeph>返回的结果集始终为<codeph>FETCH_FORWARD</codeph>和<codeph>CONCUR_READ_ONLY</codeph>。
          </li>
        <li id="pv157575">元数据仅在PL/Java 1.1或更高版本中可用。
          </li>
        <li id="pv157576"><codeph>CallableStatement</codeph>（用于存储过程）没有实现。
          </li>
        <li id="pv157577"><codeph>Clob</codeph>和<codeph>Blob</codeph>类型未完全实现，需要更多工作。
          <codeph>byte[]</codeph>和<codeph>String</codeph>可分别用于<codeph>bytea</codeph>和<codeph>text</codeph>。
          </li>
      </ul>
    </body>
  </topic>
  <topic id="topic25" xml:lang="en">
    <title id="pv157578">异常处理</title>
    <body>
      <p>您可以像其他任何异常一样捕获并处理Greenplum数据库后端中的异常。
        后端的ErrorData结构作为一个名为<codeph>org.postgresql.pljava.ServerException</codeph>(从<codeph>java.sql.SQLException</codeph>中派生)的类中的属性公开，
        并且Java try/catch机制与后端机制同步。
        </p>
      <note type="important">在函数返回之前，用户将无法继续执行后端函数，并且在后端生成异常时传播错误，除非用户使用了保存点。
        当回滚保存点时，异常条件被重置，用户可以继续执行。
        </note>
    </body>
  </topic>
  <topic id="topic26" xml:lang="en">
    <title id="pv157582">保存点</title>
    <body>
      <p>Greenplum数据库保存点使用java.sql.Connection接口公开。有两个限制。
        </p>
      <ul>
        <li id="pv157584">必须在设置的函数中回滚或释放保存点。</li>
        <li id="pv157585">保存点不能超过其设置的功能。</li>
      </ul>
    </body>
  </topic>
  <topic id="topic27" xml:lang="en">
    <title id="pv157586">日志</title>
    <body>
      <p>PL/Java使用标准的Java Logger。因此，用户可以按如下写：
        </p>
      <codeblock>Logger.getAnonymousLogger().info( "Time is " + new 
Date(System.currentTimeMillis()));</codeblock>
      <p>目前，记录器使用一个处理程序来映射Greenplum数据库配置设置的当前状态<codeph>log_min_messages</codeph>到有效的Logger级别，
        并使用Greenplum数据库后端功能输出所有消息<codeph>elog()</codeph>。
        </p>
      <note>第一次执行会话中的PL/Java函数时，将从数据库中读取<codeph>log_min_messages</codeph>设置。
        在Java端，在特定会话中执行第一个PL/Java函数之后，设置不会更改，直到重新启动使用PL/Java的Greenplum数据库会话。
        </note>
      <p>Logger级别和Greenplum数据库后端级别之间适用以下映射。
        </p>
      <table id="pv157590">
        <title>PL/Java日志级别</title>
        <tgroup cols="2">
          <colspec colnum="1" colname="col1" colwidth="131.25pt"/>
          <colspec colnum="2" colname="col2" colwidth="165pt"/>
          <thead>
            <row>
              <entry colname="col1">java.util.logging.Level</entry>
              <entry colname="col2">Greenplum数据库级别</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">SEVERE ERROR</entry>
              <entry colname="col2">ERROR</entry>
            </row>
            <row>
              <entry colname="col1">WARNING</entry>
              <entry colname="col2">WARNING</entry>
            </row>
            <row>
              <entry colname="col1">CONFIG</entry>
              <entry colname="col2">LOG</entry>
            </row>
            <row>
              <entry colname="col1">INFO</entry>
              <entry colname="col2">INFO</entry>
            </row>
            <row>
              <entry colname="col1">FINE</entry>
              <entry colname="col2">DEBUG1</entry>
            </row>
            <row>
              <entry colname="col1">FINER</entry>
              <entry colname="col2">DEBUG2</entry>
            </row>
            <row>
              <entry colname="col1">FINEST</entry>
              <entry colname="col2">DEBUG3</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic id="topic28" xml:lang="en">
    <title id="pv157624">安全</title>
    <body>
      <ul>
        <li id="pv165238">
          <xref href="#topic29" type="topic" format="dita"/>
        </li>
        <li id="pv165263">
          <xref href="#topic30" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic29" xml:lang="en">
      <title id="pv157625">安装</title>
      <body>
        <p>只有数据库超级用户才可以安装PL/Java。
          使用SECURITY DEFINER安装PL/Java实用程序函数，以便它们执行以授予函数创建者的访问权限。
          </p>
      </body>
    </topic>
    <topic id="topic30" xml:lang="en">
      <title id="pv157627">可信语言</title>
      <body>
        <p>PL/Java是一种<i>可信</i>语言。
          可信的PL/Java语言无法访问PostgreSQL定义可信语言所规定的文件系统。
          任何数据库用户都可以创建和访问受信任的语言的函数。
          </p>
        <p>PL/Java还为语言<codeph>javau</codeph>安装语言处理程序。
          此版本不受信任，只有超级用户可以创建使用它的新函数。
          任何用户都可以调用这些函数。
          </p>
      </body>
    </topic>
  </topic>
  <topic id="topic33" xml:lang="en">
    <title id="pv157633">一些PL/Java问题和解决方案</title>
    <body>
      <p>当编写PL/Java时，将JVM映射到与Greenplum数据库后端代码相同的进程空间中，对于多个线程，异常处理和内存管理，已经出现了一些问题。
        这里是简要说明如何解决这些问题。
        </p>
      <ul>
        <li id="pv165334">
          <xref href="#topic34" type="topic" format="dita"/>
        </li>
        <li id="pv165352">
          <xref href="#topic36" type="topic" format="dita"/>
        </li>
        <li id="pv165359">
          <xref href="#topic38" type="topic" format="dita"/>
        </li>
      </ul>
    </body>
    <topic id="topic34" xml:lang="en">
      <title id="pv157635">多线程</title>
      <body>
        <p>Java本身就是多线程的。
          Greenplum数据库后端不是。
          没有什么可以阻止开发人员在Java代码中使用多个Threads类。
          调用后端的终结器可能是从背景垃圾回收线程中产生的。
          可能使用的几个第三方Java包使用多个线程。
          该模式在同一过程中如何与Greenplum数据库后端共存？
          </p>
      </body>
      <topic id="topic35" xml:lang="en">
        <title>解决方案</title>
        <body>
          <p>解决方案很简单。
            PL/Java定义了一个特殊对象<codeph>Backend.THREADLOCK</codeph>。
            当初始化PL/Java时，后端立即抓取该对象监视器（即它将在​​此对象上同步）。
            当后端调用Java函数时，监视器将被释放，然后在调用返回时立即恢复。
            来自Java的所有调用到后端代码都在同一个锁上同步。
            这确保一次只能有一个线程可以从Java调用后端，并且只能在后端正在等待返回Java函数调用的时候调用。
            </p>
        </body>
      </topic>
    </topic>
    <topic id="topic36" xml:lang="en">
      <title id="pv157639">异常处理</title>
      <body>
        <p>Java经常使用try/catch/finally块。
          Greenplum数据库有时会使用一个异常机制来调用<codeph>longjmp</codeph>来将控件转移到已知状态。
          这样的跳转通常会有效地绕过JVM。
          </p>
      </body>
      <topic id="topic37" xml:lang="en">
        <title>解决方案</title>
        <body>
          <p>后端现在允许使用宏<codeph>PG_TRY/PG_CATCH</codeph>/<codeph>PG_END_TRY</codeph>捕获错误，
            并且在catch块中，可以使用ErrorData结构检查错误。
            PL/Java实现了一个名为<codeph>org.postgresql.pljava.ServerException</codeph>的<codeph>java.sql.SQLException</codeph>子类。
            可以从该异常中检索和检查ErrorData。
            允许捕获处理程序发送回滚到保存点。
            回滚成功后，执行可以继续。
            </p>
        </body>
      </topic>
    </topic>
    <topic id="topic38" xml:lang="en">
      <title id="pv157643">Java垃圾收集器与palloc()和堆栈分配</title>
      <body>
        <p>原始类型始终按值传递。
          包括<codeph>String</codeph>类型(这是必需的，因为Java使用双字节字符)。
          复杂类型通常包含在Java对象中并通过引用传递。
          例如，Java对象可以包含指向palloc'ed或stack分配的内存的指针，并使用原生的JNI调用来提取和操作数据。
          一旦调用结束，这些数据将变得陈旧。
          进一步尝试访问这些数据最多只会产生非常不可预知的结果，但更有可能导致内存错误和崩溃。
          </p>
      </body>
      <topic id="topic39" xml:lang="en">
        <title>解决方案</title>
        <body>
          <p>PL/Java包含的代码可以确保当MemoryContext或堆栈分配超出范围时，陈旧的指针被清除。
            Java包装器对象可能会生效，但是使用它们的任何尝试将导致陈旧的原生处理异常。
            </p>
        </body>
      </topic>
    </topic>
  </topic>
  <topic id="topic40" xml:lang="en">
    <title id="pv158163">示例</title>
    <body>
      <p>以下简单的Java示例创建一个包含单个方法并运行该方法的JAR文件。
        </p>
      <note type="note">该示例需要Java SDK来编译Java文件。</note>
      <p>以下方法返回一个子字符串。</p>
      <codeblock>{
public static String substring(String text, int beginIndex,
  int endIndex)
    {
    return text.substring(beginIndex, endIndex);
    }
}</codeblock>
      <p>在文本文件<codeph>example.class</codeph>中输入这些Java代码。</p>
      <p><codeph>manifest.txt</codeph>文件的内容：</p>
      <codeblock>Manifest-Version: 1.0
Main-Class: Example
Specification-Title: "Example"
Specification-Version: "1.0"
Created-By: 1.6.0_35-b10-428-11M3811
Build-Date: 01/20/2013 10:09 AM</codeblock>
      <p>编译java代码：</p>
      <codeblock>javac *.java</codeblock>
      <p>创建名为analytics.jar的JAR存档，其中包含JAR中的类文件和清单文件MANIFEST文件。
        </p>
      <codeblock>jar cfm analytics.jar manifest.txt *.class</codeblock>
      <p>将jar文件上传到Greenplum master主机。</p>
      <p>运行<codeph>gpscp</codeph>实用程序将jar文件复制到Greenplum Java目录。
        使用<codeph>-f</codeph>选项指定包含master节点和segment节点主机列表的文件。
        </p>
      <codeblock>gpscp -f gphosts_file analytics.jar 
=:/usr/local/greenplum-db/lib/postgresql/java/</codeblock>
      <p>使用<codeph>gpconfig</codeph>程序设置Greenplum<codeph>pljava_classpath</codeph>服务器配置参数。
        该参数列出已安装的jar文件。
        </p>
      <codeblock>gpconfig -c pljava_classpath -v 'analytics.jar'</codeblock>
      <p>运行<codeph>gpstop</codeph>实用程序<codeph>-u</codeph>选项重新加载配置文件。
        </p>
      <codeblock>gpstop -u</codeblock>
      <p>来自<codeph>psql</codeph>命令行，运行以下命令显示已安装的jar文件。
        </p>
      <codeblock>show pljava_classpath</codeblock>
      <p>以下SQL命令创建一个表并定义一个Java函数来测试jar文件中的方法：
        </p>
      <codeblock>create table temp (a varchar) distributed randomly; 
insert into temp values ('my string'); 
--Example function 
create or replace function java_substring(varchar, int, int) 
returns varchar as 'Example.substring' language java; 
--Example execution 
select java_substring(a, 1, 5) from temp;</codeblock>
      <p>用户可以将内容放在一个文件<codeph>mysample.sql</codeph>中，并从<codeph>psql</codeph>命令行运行该命令:
        </p>
      <codeblock>> \i mysample.sql </codeblock>
      <p>输出类似于：</p>
      <codeblock>java_substring
----------------
 y st
(1 row)</codeblock>
    </body>
  </topic>
  <topic id="topic41" xml:lang="en">
    <title id="pv157762">参考</title>
    <body>
      <p>The PL/Java Github wiki page - <xref href="https://github.com/tada/pljava/wiki"
          format="html" scope="external">https://github.com/tada/pljava/wiki</xref>.</p>
      <p> PL/Java 1.5.0 release - <xref href="https://github.com/tada/pljava/tree/REL1_5_STABLE"
          format="html" scope="external"
        >https://github.com/tada/pljava/tree/REL1_5_STABLE</xref>.</p>
    </body>
  </topic>
</topic>
