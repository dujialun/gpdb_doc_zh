<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="py212122">Greenplum Partner Connector API</title>
  <body>
      <p>使用Greenplum Partner Connector API（GPPC API），
        您可以使用C和C++编程语言编写可移植的Greenplum数据库用户定义函数（UDF）。
        使用GPPC API开发的函数不需要重新编译或修改即可使用较旧或较新的Greenplum数据库版本。
        </p>
      <p>可以使用Greenplum数据库中的SQL调用您写入GPPC API的函数。
        API提供了一组函数和宏，可用于通过服务器编程接口（SPI）发出SQL命令，操作简单和复合数据类型函数参数和返回值，管理内存和处理数据。
        </p>
      <p>您将使用GPPC API开发的C/C++函数编译到共享库中。
        在Greenplum数据库群集中安装共享库并将GPPC函数注册为SQL UDF之后，Greenplum数据库用户可以使用GPPC函数。
        </p>
      <note>Greenplum Partner Connector支持Greenplum数据库版本4.3.5.0及更高版本。</note>
    <p>本主题包含以下信息：</p>
    <ul>
      <li id="py219392">
        <xref href="#topic_dev" type="topic" format="dita"/><ul>
          <li><xref href="#topic_reqs" type="topic" format="dita"/></li>
          <li><xref href="#topic_files" type="topic" format="dita"/></li>
          <li><xref href="#topic_data" type="topic" format="dita"/></li>
          <li><xref href="#topic_argres" type="topic" format="dita"/></li>
          <li><xref href="#topic_mem" type="topic" format="dita"/></li>
          <li><xref href="#topic_varlentext" type="topic" format="dita"/></li>
          <li><xref href="#topic_errrpt" type="topic" format="dita"/></li>
          <li><xref href="#topic_spi" type="topic" format="dita"/></li>
          <li><xref href="#topic_tuple" type="topic" format="dita"/></li>
          <li><xref href="#topic_srf" type="topic" format="dita"/></li>
          <li><xref href="#topic_tblfunc" type="topic" format="dita"/></li>
          <li><xref href="#topic_limits" type="topic" format="dita"/></li>
          <li><xref href="#topic_samplecode" type="topic" format="dita"/></li>
        </ul>
      </li>
      <li id="py219393">
        <xref href="#topic_build" type="topic" format="dita"/>
      </li>
      <li id="py219391">
        <xref href="#topic_reg" type="topic" format="dita"/>
      </li>
      <li id="py219394">
        <xref href="#topic_deploy" type="topic" format="dita"/>
      </li>
      <li id="py219396">
        <xref href="#topic_example_text" type="topic" format="dita"/>
      </li>
      <li id="py219397">
        <xref href="#topic_example_srf" type="topic" format="dita"/>
      </li>
    </ul>
  </body>

  <topic id="topic_dev" xml:lang="en">
    <title id="py21716799">使用GPPC API</title>
    <body>
      <p>GPPC API与PostgreSQL定义的C语言函数共享一些概念。
        有关开发C语言函数的详细信息，请参阅PostgreSQL文档中的<xref href="https://www.postgresql.org/docs/9.4/xfunc-c.html" format="html" scope="external">C语言函数</xref>。
        </p>
      <p>GPPC API是一个包装器，它使C/C++函数可以在Greenplum数据库中调用SQL。
        这个包装器通过API定义的函数和宏对表和数据操作以及SPI操作进行规范化来屏蔽您从Greenplum数据库更改中编写的GPPC函数。
        </p>
      <p>GPPC API包括以下函数和宏：</p><ul>
        <li>对基础和复合数据类型进行操作。</li>
        <li>处理函数参数和返回值。</li>
        <li>分配和释放内存。</li>
        <li>记录并向客户报告错误。</li>
        <li>发出SPI查询。</li>
        <li>返回一个表或一组行。</li>
        <li>将表作为函数输入参数。</li>
      </ul>
    </body>
    <topic id="topic_reqs" xml:lang="en">
      <title id="py217167">要求</title>
      <body>
        <p>使用GPPC API进行开发时：</p><ul>
          <li>您必须在具有与Greenplum数据库主机相同的硬件和软件体系结构的系统上开发代码。
            </li>
          <li>您必须使用C或C++编程语言编写GPPC函数。</li>
          <li>函数代码必须使用GPPC API，数据类型和宏。</li>
          <li>函数代码不得使用PostgreSQL C语言函数API，头文件，函数或宏。
            </li>
          <li>函数代码不能<codeph>#include</codeph> <codeph>postgres.h</codeph>头文件或使用<codeph>PG_MODULE_MAGIC</codeph>。
            </li>
          <li>您必须仅使用GPPC包装的内存函数来分配和释放内存。
            请参阅<xref href="#topic_mem" format="dita"/>。
            </li>
          <li>目标文件中的符号名称不得相互冲突，也不得与Greenplum数据库服务器中定义的符号冲突。
            如果收到此类错误消息，则必须重命名函数或变量。
            </li>
        </ul>
      </body>
    </topic>
    <topic id="topic_files" xml:lang="en">
      <title id="py217167">头文件和库文件</title>
      <body>
        <p>GPPC头文件和库文件安装在<codeph>$GPHOME</codeph>中：</p>
        <ul>
          <li>$GPHOME/include/gppc.h - 主要的GPPC头文件</li>
          <li>$GPHOME/include/gppc_config.h - 定义GPPC版本的头文件</li>
          <li>$GPHOME/lib/libgppc.[a, so, so.1, so.1.2] - GPPC存档和共享库</li>
        </ul>
      </body>
    </topic>
    <topic id="topic_data" xml:lang="en">
      <title id="py217167">数据类型</title>
      <body>
        <p>您创建的GPPC函数将对驻留在Greenplum数据库中的数据进行操作。
          GPPC API包含等效Greenplum数据库SQL数据类型的数据类型定义。
          您必须在GPPC函数中使用这些类型。
          </p>
        <p>GPPC API定义了可用于表示任何GPPC类型的通用数据类型。
          此数据类型名为<codeph>GppcDatum</codeph>，定义如下：
          <codeblock>typedef int64_t GppcDatum;</codeblock></p>
        <p>下表标识了每个GPPC数据类型以及它映射到的SQL类型。</p>
        <table id="in201681">
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="77*"/>
          <colspec colname="col2" colnum="2" colwidth="86*"/>
          <colspec colname="col2" colnum="3" colwidth="86*"/>
          <thead>
            <row>
              <entry colname="col1">SQL类型</entry>
              <entry colname="col2">GPPC类型</entry>
              <entry colname="col3">GPPC类型的Oid</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">boolean</entry>
              <entry colname="col2">GppcBool</entry>
              <entry colname="col3">GppcOidBool</entry>
            </row>
            <row>
              <entry colname="col1">char (single byte)</entry>
              <entry colname="col2">GppcChar</entry>
              <entry colname="col3">GppcOidChar</entry>
            </row>
            <row>
              <entry colname="col1">int2/smallint</entry>
              <entry colname="col2">GppcInt2</entry>
              <entry colname="col3">GppcOidInt2</entry>
            </row>
            <row>
              <entry colname="col1">int4/integer</entry>
              <entry colname="col2">GppcInt4</entry>
              <entry colname="col3">GppcOidInt4</entry>
            </row>
            <row>
              <entry colname="col1">int8/bigint</entry>
              <entry colname="col2">GppcInt8</entry>
              <entry colname="col3">GppcOidInt8</entry>
            </row>
            <row>
              <entry colname="col1">float4/real</entry>
              <entry colname="col2">GppcFloat4</entry>
              <entry colname="col3">GppcOidFloat4</entry>
            </row>
            <row>
              <entry colname="col1">float8/double</entry>
              <entry colname="col2">GppcFloat8</entry>
              <entry colname="col3">GppcOidFloat8</entry>
            </row>
            <row>
              <entry colname="col1">text</entry>
              <entry colname="col2">*GppcText</entry>
              <entry colname="col3">GppcOidText</entry>
            </row>
            <row>
              <entry colname="col1">varchar</entry>
              <entry colname="col2">*GppcVarChar</entry>
              <entry colname="col3">GppcOidVarChar</entry>
            </row>
            <row>
              <entry colname="col1">char</entry>
              <entry colname="col2">*GppcBpChar</entry>
              <entry colname="col3">GppcOidBpChar</entry>
            </row>
            <row>
              <entry colname="col1">bytea</entry>
              <entry colname="col2">*GppcBytea</entry>
              <entry colname="col3">GppcOidBytea</entry>
            </row>
            <row>
              <entry colname="col1">numeric</entry>
              <entry colname="col2">*GppcNumeric</entry>
              <entry colname="col3">GppcOidNumeric</entry>
            </row>
            <row>
              <entry colname="col1">date</entry>
              <entry colname="col2">GppcDate</entry>
              <entry colname="col3">GppcOidDate</entry>
            </row>
            <row>
              <entry colname="col1">time</entry>
              <entry colname="col2">GppcTime</entry>
              <entry colname="col3">GppcOidTime</entry>
            </row>
            <row>
              <entry colname="col1">timetz</entry>
              <entry colname="col2">*GppcTimeTz</entry>
              <entry colname="col3">GppcOidTimeTz</entry>
            </row>
            <row>
              <entry colname="col1">timestamp</entry>
              <entry colname="col2">GppcTimestamp</entry>
              <entry colname="col3">GppcOidTimestamp</entry>
            </row>
            <row>
              <entry colname="col1">timestamptz</entry>
              <entry colname="col2">GppcTimestampTz</entry>
              <entry colname="col3">GppcOidTimestampTz</entry>
            </row>
            <row>
              <entry colname="col1">anytable</entry>
              <entry colname="col2">GppcAnyTable</entry>
              <entry colname="col3">GppcOidAnyTable</entry>
            </row>
            <row>
              <entry colname="col1">oid</entry>
              <entry colname="col2">GppcOid</entry>
              <entry colname="col3"></entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p> </p>
        <p>GPPC API专门处理文本，数字和时间戳数据类型，提供对这些类型进行操作的函数。
          </p>
        <p>示例GPPC基本数据类型声明：<codeblock>GppcText       message;
GppcInt4       arg1;
GppcNumeric    total_sales;</codeblock></p>
        <p>GPPC API定义了在通用<codeph>GppcDatum</codeph>类型和GPPC特定类型之间进行转换的函数。
          例如，要从整数转换为datum：
          <codeblock>
GppcInt4 num = 13;
GppcDatum num_dat = GppcInt4GetDatum(num);</codeblock></p>
      </body>
      <topic id="topic_composite" xml:lang="en">
        <title id="py217167">符合类型</title>
        <body>
          <p>复合数据类型表示行或记录的结构，由字段名称列表及其数据类型组成。
            该结构信息通常被称为元组描述符。
            复合类型的实例通常称为元组或行。
            元组没有固定的布局，可以包含空字段。
            </p>
          <p>GPPC API提供了一个界面，您可以使用该界面定义元组的结构，访问和设置元组。
            当GPPC函数将表作为输入参数或返回表或记录类型集时，将使用此接口。
            本主题后面将介绍使用表中的元组和设置返回函数。
            </p>
        </body>
      </topic>
    </topic>

    <topic id="topic_argres" xml:lang="en">
      <title id="py217167">函数声明，参数和结果</title>
      <body>
        <p>GPPC API依赖于宏来声明函数并简化函数参数和结果的传递。
          这些宏包括：
          </p>
        <table id="in201681">
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="77*"/>
          <colspec colname="col2" colnum="2" colwidth="86*"/>
          <colspec colname="col3" colnum="3" colwidth="144*"/>
          <thead>
            <row>
              <entry colname="col1">任务</entry>
              <entry colname="col2">宏签名</entry>
              <entry colname="col3">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">使函数SQL-可调用</entry>
              <entry colname="col2"><codeph>GPPC_FUNCTION_INFO(<varname>function_name</varname>)</codeph></entry>
              <entry colname="col3">粘贴使函数<codeph><varname>function_name</varname></codeph>SQL-可调用。</entry>
            </row>
            <row>
              <entry colname="col1">声明一个函数</entry>
              <entry colname="col2"><codeph>GppcDatum <varname>function_name</varname>(GPPC_FUNCTION_ARGS)</codeph></entry>
              <entry colname="col3">声明名为<codeph><varname>function_name</varname></codeph>的GPPC函数; 每个函数都必须具有相同的签名。</entry>
            </row>
            <row>
              <entry colname="col1">返回参数的数量</entry>
              <entry colname="col2"><codeph>GPPC_NARGS()</codeph></entry>
              <entry colname="col3">返回传递给函数的参数数量。</entry>
            </row>
            <row>
              <entry colname="col1">获取参数</entry>
              <entry colname="col2"><codeph>GPPC_GETARG_&lt;ARGTYPE&gt;(<varname>arg_num</varname>)</codeph></entry>
              <entry colname="col3">获取参数编号<varname>arg_num</varname>的值（从0开始），其中<codeph>&lt;ARGTYPE&gt;</codeph>标识参数的数据类型。
                例如，<codeph>GPPC_GETARG_FLOAT8(0)</codeph>。
              </entry>
            </row>
            <row>
              <entry colname="col1">获取并创建文本类型参数的副本</entry>
              <entry colname="col2"><codeph>GPPC_GETARG_&lt;ARGTYPE&gt;_COPY(<varname>arg_num</varname>)</codeph></entry>
              <entry colname="col3">获取并复制参数号<varname>arg_num</varname>的值（从0开始）。
                <codeph>&lt;ARGTYPE&gt;</codeph>标识文本类型（text，varchar，bpchar，bytea）。
                例如，<codeph>GPPC_GETARG_BYTEA_COPY(1)</codeph>。
                </entry>
            </row>
            <row>
              <entry colname="col1">确定参数是否为NULL</entry>
              <entry colname="col2"><codeph>GPPC_ARGISNULL(<varname>arg_num</varname>)</codeph></entry>
              <entry colname="col3">返回参数编号<codeph><varname>arg_num</varname></codeph>是否为NULL。</entry>
            </row>
            <row>
              <entry colname="col1">返回结果</entry>
              <entry colname="col2"><codeph>GPPC_RETURN_&lt;ARGTYPE&gt;(<varname>return_val</varname>)</codeph></entry>
              <entry colname="col3">返回值<codeph><varname>return_val</varname></codeph>，其中<codeph>&lt;ARGTYPE&gt;</codeph>标识返回值的数据类型。
                例如，<codeph>GPPC_RETURN_INT4(131)</codeph>。
              </entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p>  </p>
         <p>定义和实现GPPC函数时，必须使用上面标识的两个声明使用GPPC API声明它。
           例如，要声明名为<codeph>add_int4s()</codeph>的GPPC函数：
           <codeblock>GPPC_FUNCTION_INFO(add_int4s);
GppcDatum add_int4s(GPPC_FUNCTION_ARGS);

GppcDatum
add_int4s(GPPC_FUNCTION_ARGS)
{
  // code here
}</codeblock></p>
        <p>如果<codeph>add_int4s()</codeph>函数接受两个<codeph>int4</codeph>类型的输入参数，则使用<codeph>GPPC_GETARG_INT4(<varname>arg_num</varname>)</codeph>宏来访问参数值。
          参数索引从0开始。例如：
          <codeblock>GppcInt4  first_int = GPPC_GETARG_INT4(0);
GppcInt4  second_int = GPPC_GETARG_INT4(1);</codeblock>  </p>
        <p>如果<codeph>add_int4s()</codeph>返回两个输入参数的总和，则使用<codeph>GPPC_RETURN_INT8(<varname>return_val</varname>)</codeph>宏来返回此总和。
          例如：
          <codeblock>GppcInt8  sum = first_int + second_int;
GPPC_RETURN_INT8(sum);</codeblock>  </p>
         <p>完整的GPPC函数：<codeblock>GPPC_FUNCTION_INFO(add_int4s);
GppcDatum add_int4s(GPPC_FUNCTION_ARGS);

GppcDatum
add_int4s(GPPC_FUNCTION_ARGS)
{
  // get input arguments
  GppcInt4    first_int = GPPC_GETARG_INT4(0);
  GppcInt4    second_int = GPPC_GETARG_INT4(1);

  // add the arguments
  GppcInt8    sum = first_int + second_int;

  // return the sum
  GPPC_RETURN_INT8(sum);
}</codeblock></p>
      </body>
    </topic>

    <topic id="topic_mem" xml:lang="en">
      <title id="py217167">内存处理</title>
      <body>
        <p>GPPC API提供用于分配和释放内存的函数，包括文本内存。
          必须将这些函数用于所有内存操作。
          </p>
        <table id="in201681">
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="86*"/>
          <colspec colname="col2" colnum="2" colwidth="77*"/>
          <thead>
            <row>
              <entry colname="col1">函数名</entry>
              <entry colname="col2">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">void *GppcAlloc( size_t <varname>num</varname> )</entry>
              <entry colname="col2">分配<varname>num</varname>个字节的未初始化内存。</entry>
            </row>
            <row>
              <entry colname="col1">void *GppcAlloc0( size_t <varname>num</varname> )</entry>
              <entry colname="col2">分配<varname>num</varname>个字节的初始化为0内存。</entry>
            </row>
            <row>
              <entry colname="col1">void *GppcRealloc( void *<varname>ptr</varname>, size_t <varname>num</varname> )</entry>
              <entry colname="col2">调整预分配的内存大小。</entry>
            </row>
            <row>
              <entry colname="col1">void GppcFree( void *<varname>ptr</varname> )</entry>
              <entry colname="col2">释放分配的内存。</entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p>分配内存后，可以使用<codeph>memcpy()</codeph>等系统函数来设置数据。
          </p>
        <p>以下示例分配<codeph>GppcDatum</codeph>数组并将数组设置为函数输入参数的datum版本：
          <codeblock>GppcDatum  *values;
int attnum = GPPC_NARGS();

// allocate memory for attnum values
values = GppcAlloc( sizeof(GppcDatum) * attnum );

// set the values
for( int i=0; i&lt;attnum; i++ ) {
    GppcDatum d = GPPC_GETARG_DATUM(i);
    values[i] = d;
}</codeblock></p>

        <p>为GPPC函数分配内存时，可以在当前上下文中分配它。
          GPPC API包括返回，创建，切换和重置内存上下文的函数。
          </p>
        <table id="in201681">
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="100*"/>
          <colspec colname="col2" colnum="2" colwidth="63*"/>
          <thead>
            <row>
              <entry colname="col1">函数名</entry>
              <entry colname="col2">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">GppcMemoryContext GppcGetCurrentMemoryContext(void)</entry>
              <entry colname="col2">返回当前内存上下文。</entry>
            </row>
            <row>
              <entry colname="col1">GppcMemoryContext GppcMemoryContextCreate(GppcMemoryContext <varname>parent</varname>)</entry>
              <entry colname="col2">在<varname>parent</varname>下创建新的内存上下文。</entry>
            </row>
            <row>
              <entry colname="col1">GppcMemoryContext GppcMemoryContextSwitchTo(GppcMemoryContext <varname>context</varname>)</entry>
              <entry colname="col2">切换到内存上下文<varname>context</varname>。</entry>
            </row>
            <row>
              <entry colname="col1">void GppcMemoryContextReset(GppcMemoryContext <varname>context</varname>)</entry>
              <entry colname="col2">在内存上下文<varname>context</varname>中重置（释放）内存。</entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p>Greenplum数据库通常在每元组上下文中调用一个SQL调用的函数，它在每次服务器后端处理表行时创建和删除。
          不要假设在当前内存上下文中分配的内存在多个函数调用中可用。
          </p>
      </body>
    </topic>

    <topic id="topic_varlentext" xml:lang="en">
      <title id="py217167">使用可变长度文本类型</title>
      <body>
        <p>GPPC API支持可变长度文本，varchar，空白填充和字节数组类型。
          在对这些数据类型进行操作时，必须使用GPPC API提供的函数。
          GPPC API中提供的可变文本操作函数包括为其分配内存，确定字符串长度，获取字符串指针以及访问这些类型的函数：
          </p>
          <table id="in201681">
          <tgroup cols="2">
            <colspec colname="col1" colnum="1" colwidth="105*"/>
            <colspec colname="col2" colnum="2" colwidth="75*"/>
            <thead>
              <row>
                <entry colname="col1">函数名</entry>
                <entry colname="col2">描述</entry>
              </row>
            </thead>
            <tbody>
            <row>
              <entry colname="col1">GppcText GppcAllocText( size_t <varname>len</varname> )<p>GppcVarChar GppcAllocVarChar( size_t <varname>len</varname> )</p><p>GppcBpChar GppcAllocBpChar( size_t <varname>len</varname> )</p><p>GppcBytea GppcAllocBytea( size_t <varname>len</varname> )</p></entry>
              <entry colname="col2">为不同长度类型分配<varname>len</varname>个字节的内存。</entry>
            </row>
            <row>
              <entry colname="col1">size_t GppcGetTextLength( GppcText <varname>s</varname> )<p>size_t GppcGetVarCharLength( GppcVarChar <varname>s</varname> )</p><p>size_t GppcGetBpCharLength( GppcBpChar <varname>s</varname> )</p><p>size_t GppcGetByteaLength( GppcBytea <varname>b</varname> )</p></entry>
              <entry colname="col2">返回内存块中的字节数。</entry>
            </row>
              <row>
                <entry colname="col1">char *GppcGetTextPointer( GppcText <varname>s</varname> )<p>char *GppcGetVarCharPointer( GppcVarChar <varname>s</varname> )</p><p>char *GppcGetBpCharPointer( GppcBpChar <varname>s</varname> )</p><p>char *GppcGetByteaPointer( GppcBytea <varname>b</varname> )</p></entry>
                <entry colname="col2">返回一个指向内存块头部的字符串指针。该字符串不以空值终止。</entry>
              </row>
              <row>
                <entry colname="col1">char *GppcTextGetCString( GppcText <varname>s</varname> )<p>char *GppcVarCharGetCString( GppcVarChar <varname>s</varname> )</p><p>char *GppcBpCharGetCString( GppcBpChar <varname>s</varname> )</p></entry>
                <entry colname="col2">返回一个指向内存块头部的字符串指针。该字符串以空值终止。</entry>
              </row>
              <row>
                <entry colname="col1">GppcText *GppcCStringGetText( const char *<varname>s</varname> )<p>GppcVarChar *GppcCStringGetVarChar( const char *<varname>s</varname> )</p><p>GppcBpChar *GppcCStringGetBpChar( const char *<varname>s</varname> )</p></entry>
                <entry colname="col2">从字符串构建变长类型。</entry>
              </row>
            </tbody>
          </tgroup>
          </table>
          <p><codeph>GppcGet&lt;VLEN_ARGTYPE>Pointer()</codeph>函数返回的内存可能指向实际的数据库内容。
            请勿修改内存内容。
            GPPC API提供了在需要时为这些类型分配内存的函数。
            分配内存后，可以使用<codeph>memcpy()</codeph>等系统函数来设置数据。
            </p>
          <p>以下示例处理文本输入参数，并为文本字符串连接操作分配和设置结果内存：
            <codeblock>GppcText first_textstr = GPPC_GETARG_TEXT(0);
GppcText second_textstr = GPPC_GETARG_TEXT(1);

// determine the size of the concatenated string and allocate
// text memory of this size
size_t arg0_len = GppcGetTextLength(first_textstr);
size_t arg1_len = GppcGetTextLength(second_textstr);
GppcText retstring = GppcAllocText(arg0_len + arg1_len);

// construct the concatenated return string; copying each string
// individually
memcpy(GppcGetTextPointer(retstring), GppcGetTextPointer(first_textstr), arg0_len);
memcpy(GppcGetTextPointer(retstring) + arg0_len, GppcGetTextPointer(second_textstr), arg1_len);
</codeblock></p>
        </body>
    </topic>

    <topic id="topic_errrpt" xml:lang="en">
      <title id="py217167">错误报告和记录</title>
      <body>
        <p>GPPC API提供错误报告和日志记录函数。
          API定义的报告级别与Greenplum数据库中的级别相同：
          <codeblock>typedef enum GppcReportLevel
{
        GPPC_DEBUG1                             = 10,
        GPPC_DEBUG2                             = 11,
        GPPC_DEBUG3                             = 12,
        GPPC_DEBUG4                             = 13,
        GPPC_DEBUG                              = 14,
        GPPC_LOG                                = 15,
        GPPC_INFO                               = 17,
        GPPC_NOTICE                             = 18,
        GPPC_WARNING                    	= 19,
        GPPC_ERROR                              = 20,
} GppcReportLevel;
</codeblock>（Greenplum数据库<xref href="../config_params/guc-list.xml#client_min_messages"><codeph>client_min_messages</codeph></xref>服务器配置参数控制当前客户端日志记录级别。
          <xref href="../config_params/guc-list.xml#client_min_messages"><codeph>log_min_messages</codeph></xref>配置参数控制当前日志到日志文件级别。）
          </p>
        <p>GPPC报告包括报告级别，报告消息和可选的报告回调函数。
          </p>
        <p>GPPC API提供的报告和处理函数包括：</p>
        <table id="in201681">
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="80*"/>
          <colspec colname="col2" colnum="2" colwidth="83*"/>
          <thead>
            <row>
              <entry colname="col1">函数名</entry>
              <entry colname="col2">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">GppcReport()</entry>
              <entry colname="col2">格式化并打印/记录指定报告级别的字符串。</entry>
            </row>
            <row>
              <entry colname="col1">GppcInstallReportCallback()</entry>
              <entry colname="col2">注册/安装报告回调函数。</entry>
            </row>
            <row>
              <entry colname="col1">GppcUninstallReportCallback()</entry>
              <entry colname="col2">卸载报告回调函数。</entry>
            </row>
            <row>
              <entry colname="col1">GppcGetReportLevel()</entry>
              <entry colname="col2">从错误报告中检索级别。</entry>
            </row>
            <row>
              <entry colname="col1">GppcGetReportMessage()</entry>
              <entry colname="col2">从错误报告中检索消息。</entry>
            </row>
            <row>
              <entry colname="col1">GppcCheckForInterrupts()</entry>
              <entry colname="col2">如果中断挂起则出错。</entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p> </p>
        <p><codeph>GppcReport()</codeph>函数签名是：<codeblock>void GppcReport(GppcReportLevel elevel, const char *fmt, ...);</codeblock></p>
        <p><codeph>GppcReport()</codeph>采用类似于<codeph>printf()</codeph>的格式化字符串输入参数。
          以下示例生成格式化GPPC文本参数的错误级别报告消息：
          <codeblock>GppcText  uname = GPPC_GETARG_TEXT(1);
GppcReport(GPPC_ERROR, "Unknown user name: %s", GppcTextGetCString(uname));</codeblock></p>
        <p>有关示例报告回调处理程序，请参阅<xref href="https://github.com/greenplum-db/gpdb/tree/master/src/interfaces/gppc/test" format="html" scope="external">GPPC示例代码</xref>。
          </p>
      </body>
    </topic>

    <topic id="topic_spi" xml:lang="en">
      <title id="py217167">SPI函数</title>
      <body>
        <p>Greenplum数据库服务器编程接口（SPI）为C/C++函数的编写者提供了在GPPC函数中运行SQL命令的能力。
          有关SPI函数的其他信息，请参阅PostgreSQL文档中的<xref href="https://www.postgresql.org/docs/9.4/spi.html"
                                              scope="external"
                                              format="html">服务器编程接口</xref>。
          </p>
       <p>GPPC API公开了PostgreSQL SPI函数的子集。
         通过该子集，您可以在GPPC函数中发出SPI查询并检索SPI结果值。
         GPPC SPI包装器函数是：
         </p>
        <table id="in201681">
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="40*"/>
          <colspec colname="col2" colnum="2" colwidth="57"/>
          <colspec colname="col3" colnum="3" colwidth="77*"/>
          <thead>
            <row>
              <entry colname="col1">SPI函数名</entry>
              <entry colname="col2">GPPC函数名</entry>
              <entry colname="col3">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">SPI_connect()</entry>
              <entry colname="col2">GppcSPIConnect()</entry>
              <entry colname="col3">连接到Greenplum数据库服务器编程接口。</entry>
            </row>
            <row>
              <entry colname="col1">SPI_finish()</entry>
              <entry colname="col2">GppcSPIFinish()</entry>
              <entry colname="col3">断开与Greenplum数据库服务器编程接口的连接。</entry>
            </row>
            <row>
              <entry colname="col1">SPI_exec()</entry>
              <entry colname="col2">GppcSPIExec()</entry>
              <entry colname="col3">执行SQL语句，返回行数。</entry>
            </row>
            <row>
              <entry colname="col1" morerows="3">SPI_getvalue()</entry>
              <entry colname="col2">GppcSPIGetValue()</entry>
              <entry colname="col3">从SQL结果中按编号检索特定属性的值作为字符串。</entry>
            </row>
            <row>
              <entry colname="col2">GppcSPIGetDatum()</entry>
              <entry colname="col3">从SQL结果中按编号检索特定属性的值作为<codeph>GppcDatum</codeph>。</entry>
            </row>
            <row>
              <entry colname="col2">GppcSPIGetValueByName()</entry>
              <entry colname="col3">按名称从SQL结果中检索特定属性的值作为字符串。</entry>
            </row>
            <row>
              <entry colname="col2">GppcSPIGetDatumByName()</entry>
              <entry colname="col3">按名称从SQL结果中检索特定属性的值作为<codeph>GppcDatum</codeph>。</entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p>  </p>
        <p>创建访问服务器编程接口的GPPC函数时，您的函数应符合以下流程：
          <codeblock>GppcSPIConnect();
GppcSPIExec(...)
// process the results - GppcSPIGetValue(...), GppcSPIGetDatum(...)
GppcSPIFinish()</codeblock></p>
        <p>您可以使用<codeph>GppcSPIExec()</codeph>在GPPC函数中执行SQL语句。
          调用此函数时，还可以标识要返回的最大行数。
          <codeph>GppcSPIExec()</codeph>的函数签名是：
          <codeblock>GppcSPIResult GppcSPIExec(const char *sql_statement, long rcount);</codeblock></p>
        <p><codeph>GppcSPIExec()</codeph>返回<codeph>GppcSPIResult</codeph>结构。
          该结构表示SPI结果数据。
          它包括指向数据的指针，有关处理的行数的信息，计数器和结果代码。
          GPPC API定义此结构如下：
          <codeblock>typedef struct GppcSPIResultData
{
    struct GppcSPITupleTableData   *tuptable;
    uint32_t                       processed;
    uint32_t                       current;
    int                            rescode;
} GppcSPIResultData;
typedef GppcSPIResultData *GppcSPIResult;</codeblock></p>
        <p>您可以设置和使用<codeph>GppcSPIResult</codeph>结构中的<codeph>current</codeph>字段来检查<codeph>tuptable</codeph>结果数据的每一行。
          </p>
        <p>以下代码摘录使用GPPC API连接到SPI，执行简单查询，循环查询结果并完成处理：
          <codeblock>GppcSPIResult   result;
char            *attname = "id";
char            *query = "SELECT i, 'foo' || i AS val FROM generate_series(1, 10)i ORDER BY 1";
bool            isnull = true;

// connect to SPI
if( GppcSPIConnect() &lt; 0 ) {
    GppcReport(GPPC_ERROR, "cannot connect to SPI");
}

// execute the query, returning all rows
result = GppcSPIExec(query, 0);

// process result
while( result->current &lt; result->processed ) {
    // get the value of attname column as a datum, making a copy
    datum = GppcSPIGetDatumByName(result, attname, &amp;isnull, true);

    // do something with value

    // move on to next row
    result->current++;
}

// complete processing
GppcSPIFinish();
</codeblock></p>
      </body>
    </topic>

    <topic id="topic_tuple" xml:lang="en">
      <title id="py21716799">关于元组描述符和元组</title>
      <body>
        <p>表或一组记录包含一个或多个元组（行）。
          元组的每个属性的结构由元组描述符定义。
          元组描述符为元组中的每个属性定义以下内容：
          <ul>
           <li>属性名称</li>
           <li>属性数据类型的对象标识符</li>
           <li>属性数据类型的字节长度</li>
           <li>属性修饰符的对象标识符</li>
        </ul></p>
        <p>GPPC API定义了一个抽象类型<codeph>GppcTupleDesc</codeph>来表示元组/行描述符。
          API还提供了可用于创建，访问和设置元组描述符的函数：
          </p>
        <table id="in201681">
          <tgroup cols="2">
            <colspec colname="col1" colnum="1" colwidth="65*"/>
            <colspec colname="col2" colnum="2" colwidth="105*"/>
            <thead>
              <row>
                <entry colname="col1">函数名称</entry>
                <entry colname="col2">描述</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="col1">GppcCreateTemplateTupleDesc()</entry>
                <entry colname="col2">创建具有指定数量的属性的空元组描述符。</entry>
              </row>
              <row>
                <entry colname="col1">GppcTupleDescInitEntry()</entry>
                <entry colname="col2">在指定位置向元组描述符添加属性。</entry>
              </row>
              <row>
                <entry colname="col1">GppcTupleDescNattrs()</entry>
                <entry colname="col2">获取元组描述符中的属性数。</entry>
              </row>
              <row>
                <entry colname="col1">GppcTupleDescAttrName()</entry>
                <entry colname="col2">获取元组描述符中特定位置（从0开始）的属性名称。</entry>
              </row>
              <row>
                <entry colname="col1">GppcTupleDescAttrType()</entry>
                <entry colname="col2">获取元组描述符中特定位置（从0开始）的属性的类型对象标识符。</entry>
              </row>
              <row>
                <entry colname="col1">GppcTupleDescAttrLen()</entry>
                <entry colname="col2">获取元组描述符中特定位置（从0开始）的属性的类型长度。</entry>
              </row>
              <row>
                <entry colname="col1">GppcTupleDescAttrTypmod()</entry>
                <entry colname="col2">获取元组描述符中特定位置（从0开始）的属性的类型修饰符对象标识符。</entry>
              </row>
            </tbody>
          </tgroup>
          </table>
             <p>  </p>
             <p>要构造元组描述符，首先要创建一个模板，然后为每个属性填写描述符字段。
               这些函数的签名是：
               <codeblock>GppcTupleDesc GppcCreateTemplateTupleDesc(int natts);
void GppcTupleDescInitEntry(GppcTupleDesc desc, uint16_t attno,
                            const char *attname, GppcOid typid, int32_t typmod);</codeblock></p>
             <p>在某些情况下，您可能希望从现有元组中的属性定义初始化元组描述符条目。
               以下函数获取元组描述符中的属性数，以及描述符中特定属性（按编号）的定义：
               <codeblock>int GppcTupleDescNattrs(GppcTupleDesc tupdesc);
const char *GppcTupleDescAttrName(GppcTupleDesc tupdesc, int16_t attno);
GppcOid GppcTupleDescAttrType(GppcTupleDesc tupdesc, int16_t attno);
int16_t GppcTupleDescAttrLen(GppcTupleDesc tupdesc, int16_t attno);
int32_t GppcTupleDescAttrTypmod(GppcTupleDesc tupdesc, int16_t attno);</codeblock></p>
             <p>以下示例初始化两个属性元组描述符。
               第一个属性使用来自不同描述符的属性定义进行初始化，第二个属性初始化为布尔类型属性：
               <codeblock>GppcTupleDesc       tdesc;
GppcTupleDesc       indesc = some_input_descriptor;

// initialize the tuple descriptor with 2 attributes
tdesc = GppcCreateTemplateTupleDesc(2);

// use third attribute from the input descriptor
GppcTupleDescInitEntry(tdesc, 1, 
	       GppcTupleDescAttrName(indesc, 2),
	       GppcTupleDescAttrType(indesc, 2),
	       GppcTupleDescAttrTypmod(indesc, 2));

// create the boolean attribute
GppcTupleDescInitEntry(tdesc, 2, "is_active", GppcOidBool, 0);
</codeblock></p>
        <p>GPPC API定义了一个抽象类型<codeph>GppcHeapTuple</codeph>来表示元组/记录/行。
          元组由其元组描述符定义，每个元组属性的值以及每个值是否为NULL的指示符。
          </p>
        <p>GPPC API提供了可用于设置和访问元组及其属性的函数：
          </p>
        <table id="in201681">
          <tgroup cols="2">
            <colspec colname="col1" colnum="1" colwidth="65*"/>
            <colspec colname="col2" colnum="2" colwidth="105*"/>
            <thead>
              <row>
                <entry colname="col1">函数名称</entry>
                <entry colname="col2">描述</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry colname="col1">GppcHeapFormTuple()</entry>
                <entry colname="col2">从<codeph>GppcDatum</codeph>数组中形成一个元组。</entry>
              </row>
              <row>
                <entry colname="col1">GppcBuildHeapTupleDatum()</entry>
                <entry colname="col2">从<codeph>GppcDatum</codeph>数组中形成一个<codeph>GppcDatum</codeph>元组。</entry>
              </row>
              <row>
                <entry colname="col1">GppcGetAttributeByName()</entry>
                <entry colname="col2">按名称从元组中获取属性。</entry>
              </row>
              <row>
                <entry colname="col1">GppcGetAttributeByNum()</entry>
                <entry colname="col2">从数字中获取元组的属性（从1开始）。</entry>
              </row>
            </tbody>
          </tgroup>
          </table>
             <p>  </p>
             <p>构建元组GPPC函数的签名是：<codeblock>GppcHeapTuple GppcHeapFormTuple(GppcTupleDesc tupdesc, GppcDatum *values, bool *nulls);
GppcDatum    GppcBuildHeapTupleDatum(GppcTupleDesc tupdesc, GppcDatum *values, bool *nulls);</codeblock></p>
             <p>以下代码摘录从上面的代码示例中的元组描述符构造<codeph>GppcDatum</codeph>元组，并从函数的整数和布尔输入参数构造：
               <codeblock>GppcDatum intarg = GPPC_GETARG_INT4(0);
GppcDatum boolarg = GPPC_GETARG_BOOL(1);
GppcDatum result, values[2];
bool nulls[2] = { false, false };

// construct the values array
values[0] = intarg;
values[1] = boolarg;
result = GppcBuildHeapTupleDatum( tdesc, values, nulls );
</codeblock></p>
      </body>
    </topic>

    <topic id="topic_srf" xml:lang="en">
        <title id="py217167">Set-Returning函数</title>
        <body>
          <p>其签名包括<codeph>RETURNS SETOF RECORD</codeph>或<codeph>RETURNS TABLE( ... )</codeph>的Greenplum数据库UDF是set-returning函数。
            </p>
          <p>GPPC API为GPPC函数返回集（例如，多行/元组）提供支持。
            Greenplum数据库为每个行或项目调用一次set-returning函数（SRF）。
            该函数必须保存足够的状态以记住它正在做什么并返回每次调用的下一行。
            您在SRF上下文中分配的内存必须在多个函数调用中存活。
            </p>
          <p>GPPC API提供宏和函数，以帮助跟踪和设置此上下文，并分配SRF内存。
            他们包括：
            </p>
        <table id="in201681">
        <tgroup cols="2">
          <colspec colname="col1" colnum="1" colwidth="40*"/>
          <colspec colname="col2" colnum="2" colwidth="60*"/>
          <thead>
            <row>
              <entry colname="col1">函数/宏名称</entry>
              <entry colname="col2">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">GPPC_SRF_RESULT_DESC()</entry>
              <entry colname="col2">获取此SRF的输出行元组描述符。结果元组描述符由输出表定义或<codeph>DESCRIBE</codeph>函数确定。</entry>
            </row>
            <row>
              <entry colname="col1">GPPC_SRF_IS_FIRSTCALL()</entry>
              <entry colname="col2">确定这是否是对SRF的第一次调用。</entry>
            </row>
            <row>
              <entry colname="col1">GPPC_SRF_FIRSTCALL_INIT()</entry>
              <entry colname="col2">初始化SRF上下文。</entry>
            </row>
            <row>
              <entry colname="col1">GPPC_SRF_PERCALL_SETUP()</entry>
              <entry colname="col2">在每次调用SRF时恢复上下文。</entry>
            </row>
            <row>
              <entry colname="col1">GPPC_SRF_RETURN_NEXT()</entry>
              <entry colname="col2">从SRF返回值并继续处理。</entry>
            </row>
            <row>
              <entry colname="col1">GPPC_SRF_RETURN_DONE()</entry>
              <entry colname="col2">SRF处理完成的信号。</entry>
            </row>
            <row>
              <entry colname="col1">GppSRFAlloc()</entry>
              <entry colname="col2">在此SRF上下文中分配内存。</entry>
            </row>
            <row>
              <entry colname="col1">GppSRFAlloc0()</entry>
              <entry colname="col2">在此SRF上下文中分配内存并将其初始化为零。</entry>
            </row>
            <row>
              <entry colname="col1">GppSRFSave()</entry>
              <entry colname="col2">在此SRF上下文中保存用户状态。</entry>
            </row>
            <row>
              <entry colname="col1">GppSRFRestore()</entry>
              <entry colname="col2">在此SRF上下文中还原用户状态。</entry>
            </row>
          </tbody>
        </tgroup>
        </table>
        <p>  </p>
        <p><codeph>GppcFuncCallContext</codeph>结构提供SRF的上下文。
          您在第一次调用SRF时创建此上下文。
          您的set-returning GPPC函数必须在每次调用时检索函数上下文。
          例如：
          <codeblock>// set function context
GppcFuncCallContext fctx;
if (GPPC_SRF_IS_FIRSTCALL()) {
    fctx = GPPC_SRF_FIRSTCALL_INIT();
}
fctx = GPPC_SRF_PERCALL_SETUP();
// process the tuple
</codeblock></p>
         <p>GPPC函数必须在返回元组结果时提供上下文或指示处理已完成。
           例如：
           <codeblock>GPPC_SRF_RETURN_NEXT(fctx, result_tuple);
// or
GPPC_SRF_RETURN_DONE(fctx);</codeblock></p>

        <p>使用<codeph>DESCRIBE</codeph>函数定义使用<codeph>RETURNS SETOF RECORD</codeph>子句的函数的输出元组描述符。
          使用<codeph>GPPC_SRF_RESULT_DESC()</codeph>宏获取使用<codeph>RETURNS TABLE( ... )</codeph>子句的函数的输出元组描述符。
          </p>
        <p>有关set-returning函数代码和部署示例，请参阅<xref href="#topic_example_srf" type="topic" format="dita"/>。
          </p>
      </body>
    </topic>

    <topic id="topic_tblfunc" xml:lang="en">
      <title id="py217167">表函数</title>
      <body>
        <p>GPPC API提供<codeph>GppcAnyTable</codeph>类型以将表作为输入参数传递给函数，或者将表作为函数结果返回。
          </p>
        <p>GPPC API中提供的与表相关的函数和宏包括：</p>
        <table id="in201681">
        <tgroup cols="2">
          <colspec colname="col1" colnum="1" colwidth="40*"/>
          <colspec colname="col2" colnum="2" colwidth="60*"/>
          <thead>
            <row>
              <entry colname="col1">函数/宏名称</entry>
              <entry colname="col2">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">GPPC_GETARG_ANYTABLE()</entry>
              <entry colname="col2">获取任何表函数参数。</entry>
            </row>
            <row>
              <entry colname="col1">GPPC_RETURN_ANYTABLE()</entry>
              <entry colname="col2">返回表。</entry>
            </row>
            <row>
              <entry colname="col1">GppcAnyTableGetTupleDesc()</entry>
              <entry colname="col2">获取表的元组描述符。</entry>
            </row>
            <row>
              <entry colname="col1">GppcAnyTableGetNextTuple()</entry>
              <entry colname="col2">获取表中的下一行。</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>  </p>
      <p>您可以使用<codeph>GPPC_GETARG_ANYTABLE()</codeph>宏来检索表输入参数。
        当您有权访问该表时，可以使用<codeph>GppcAnyTableGetTupleDesc()</codeph>函数检查该表的元组描述符。
        该函数的签名是：
        <codeblock>GppcTupleDesc GppcAnyTableGetTupleDesc(GppcAnyTable t);</codeblock></p>
       <p>例如，要检索作为函数的第一个输入参数的表的元组描述符：
         <codeblock>GppcAnyTable     intbl;
GppcTupleDesc    in_desc;

intbl = GPPC_GETARG_ANYTABLE(0);
in_desc = GppcAnyTableGetTupleDesc(intbl);</codeblock></p>
      <p><codeph>GppcAnyTableGetNextTuple()</codeph>函数从表中获取下一行。
        同样，要从上表中检索下一个元组：
        <codeblock>GppcHeapTuple    ntuple;

ntuple = GppcAnyTableGetNextTuple(intbl);</codeblock></p>
      </body>
    </topic>

    <topic id="topic_limits" xml:lang="en">
      <title id="py217167">限制</title>
      <body>
        <p>使用Greenplum数据库版本5.0.x的GPPC API不支持以下运算符：</p><ul>
          <li>integer || integer</li>
          <li>integer = text</li>
          <li>text &lt; integer</li>
        </ul>
      </body>
    </topic>

    <topic id="topic_samplecode" xml:lang="en">
      <title id="py217167">样例代码</title>
      <body>
        <p>Greenplum数据库github存储库中的<xref href="https://github.com/greenplum-db/gpdb/tree/master/src/interfaces/gppc/test" format="html" scope="external">gppc test</xref>目录包含示例GPPC代码：
          </p><ul>
          <li><codeph>gppc_demo/</codeph> - 示例代码，用于执行GPPC SPI函数，错误报告，数据类型参数和返回宏，set-returning函数和编码函数</li>
          <li><codeph>tabfunc_gppc_demo/</codeph> - 示例代码执行GPPC表和set-returning函数</li>
        </ul>
      </body>
    </topic>

  </topic>

  <topic id="topic_build" xml:lang="en">
      <title id="py217167bbb">使用PGXS构建GPPC共享库</title>
      <body>
        <p>您可以将使用GPPC API编写的函数编译到Greenplum数据库服务器按需加载的一个或多个共享库中。
          </p>
        <p>您可以使用PostgreSQL构建扩展基础结构（PGXS）根据Greenplum数据库安装为您的GPPC函数构建源代码。
          该框架自动化简单模块的通用构建规则。
          如果您有一个更复杂的用例，则需要编写自己的构建系统。
          </p>
        <p>要使用PGXS基础结构为使用GPPC API创建的函数生成共享库，请创建一个设置PGXS特定变量的简单<codeph>Makefile</codeph>。
          </p>
        <note>有关PGXS支持的<codeph>Makefile</codeph>变量的信息，
          请参阅PostgreSQL文档中的<xref href="https://www.postgresql.org/docs/9.4/extend-pgxs.html" format="html" scope="external">扩展的构建基础设施</xref>。
          </note>
        <p>例如，以下<codeph>Makefile</codeph>从名为<codeph>src1.c</codeph>和<codeph>src2.c</codeph>的两个C源文件生成名为<codeph>sharedlib_name.so</codeph>的共享库：
          <codeblock>MODULE_big = sharedlib_name
OBJS = src1.o src2.o
PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)
SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir) -lgppc

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)
include $(PGXS)</codeblock></p>

        <p><codeph>MODULE_big</codeph>标识<codeph>Makefile</codeph>生成的共享库的基本名称。
          </p>
        <p><codeph>PG_CPPFLAGS</codeph>将Greenplum数据库安装包含目录添加到编译器头文件搜索路径中。
          </p>
        <p><codeph>SHLIB_LINK</codeph>将Greenplum数据库安装库目录添加到链接器搜索路径。
          此变量还将GPPC库（<codeph>-lgppc</codeph>）添加到link命令。
          </p>
        <p><codeph>PG_CONFIG</codeph>和<codeph>PGXS</codeph>变量设置和<codeph>include</codeph>语句是必需的，
          通常位于<codeph>Makefile</codeph>的最后三行。
          </p>
      </body>
  </topic>

  <topic id="topic_reg" xml:lang="en">
      <title id="py21716799">使用Greenplum数据库注册GPPC函数</title>
      <body>
        <p>在用户可以从SQL调用GPPC函数之前，必须使用Greenplum数据库注册该函数。
          </p>
        <p>注册GPPC函数涉及将GPPC函数签名映射到SQL用户定义的函数。
          您可以使用<codeph>CREATE FUNCTION .. AS </codeph>命令定义此映射，以指定GPPC共享库名称。
          您可以选择为GPPC和SQL函数使用相同的名称或不同的名称。
          </p>
        <p>示例<codeph>CREATE FUNCTION ... AS </codeph>语法如下：
          <codeblock>CREATE FUNCTION <varname>sql_function_name</varname>(<varname>arg</varname>[, ...]) RETURNS <varname>return_type</varname>
  AS '<varname>shared_library_path</varname>'[, '<varname>gppc_function_name</varname>']
LANGUAGE C STRICT [WITH (DESCRIBE=<varname>describe_function</varname>)];</codeblock></p>
         <p>指定<codeph><varname>shared_library_path</varname></codeph>时，可以省略共享库<codeph>.so</codeph>扩展名。
           </p>
        <p>如果GPPC函数在名为<codeph>gppc_try.so</codeph>的共享库中编译和链接，
          则以下命令将本主题前面引用的示例<codeph>add_int4s()</codeph>函数注册到名为<codeph>add_two_int4s_gppc()</codeph>的SQL UDF：
          <codeblock>CREATE FUNCTION add_two_int4s_gppc(int4, int4) RETURNS int8
  AS 'gppc_try.so', 'add_int4s'
LANGUAGE C STRICT;</codeblock></p>
      </body>

  <topic id="topic_dynload" xml:lang="en">
    <title id="py217167bx">关于动态加载</title>
    <body>
      <p>您可以在<codeph>CREATE FUNCTION ... AS</codeph>命令中指定GPPC共享库的名称，
        以在Greenplum数据库的共享库中注册GPPC函数。
        Greenplum数据库动态加载程序在用户第一次调用在该共享库中链接的用户定义函数时将GPPC共享库文件加载到内存中。
        如果在<codeph>CREATE FUNCTION ... AS</codeph>命令中未提供共享库的绝对路径，
        Greenplum数据库将尝试使用以下有序步骤找到库：
        </p><ol>
        <li>如果共享库文件路径以字符串<codeph>$libdir</codeph>开头，
          则Greenplum数据库将在PostgreSQL包库目录中查找该文件。
          运行<codeph>pg_config --pkglibdir</codeph>命令以确定此目录的位置。
          </li>
        <li>如果指定了没有目录前缀的共享库文件名，
          则Greenplum数据库将在<codeph>dynamic_library_path</codeph>服务器配置参数值标识的目录中搜索该文件。
          </li>
        <li>当前的工作目录。</li></ol>
    </body>
  </topic>
  </topic>
  <topic id="topic_deploy" xml:lang="en">
      <title id="py21716799">打包和部署注意事项</title>
      <body>
        <p>您必须以适合Greenplum集群中Greenplum数据库管理员部署的形式打包GPPC共享库和SQL函数注册脚本。
          提供GPPC包的特定部署说明。
          </p>
        <p>构建程序包和部署说明时，请考虑以下事项：
          </p><ul>
          <li>考虑提供Greenplum数据库管理员运行的shell脚本或程序，以便将共享库安装到所需的文件系统位置并注册GPPC函数。
            </li>
          <li>必须将GPPC共享库安装到master主机上的相同文件系统位置以及Greenplum数据库群集中的每个segment主机上。
            </li>
          <li><codeph>gpadmin</codeph>用户必须具有遍历GPPC共享库文件的完整文件系统路径的权限。
            </li>
         <li>安装在Greenplum数据库部署中后，
           GPPC共享库的文件系统位置决定了在使用<codeph>CREATE FUNCTION ... AS</codeph>命令在库中注册函数时如何引用共享库。
           </li>
          <li>创建一个<codeph>.sql</codeph>脚本文件，为GPPC共享库中的每个GPPC函数注册一个SQL UDF。
            您在<codeph>.sql</codeph>注册脚本中创建的函数必须引用GPPC共享库的部署位置。
            在GPPC部署包中包含此脚本。
            </li>
          <li>记录运行GPPC包部署脚本的说明（如果提供）。
            </li>
          <li>如果未在程序包部署脚本中包含此任务，请记录有关安装GPPC共享库的说明。
            </li>
          <li>如果未在程序包部署脚本中包含此任务，请记录有关安装和运行函数注册脚本的说明。
            </li>
        </ul>
      </body>
  </topic>
  <topic id="topic_example_text" xml:lang="en">
    <title id="py217167">GPPC文本函数示例</title>
    <body>
      <p>在此示例中，您将开发，构建和部署GPPC共享库，并注册并运行名为<codeph>concat_two_strings</codeph>的GPPC函数。
        此函数使用GPPC API连接两个字符串参数并返回结果。
        </p>
      <p>您将在Greenplum数据库主控主机上开发GPPC函数。
        部署您在此示例中创建的GPPC共享库需要对Greenplum数据库集群的管理访问权限。
        </p>
      <p>执行以下过程以运行该示例：</p><ol>
        <li>登录Greenplum数据库主控主机并设置您的环境。例如：
          <codeblock>$ ssh gpadmin@&lt;gpmaster&gt;
gpadmin@gpmaster$ . /usr/local/greenplum-db/greenplum_path.sh</codeblock></li>
        <li>创建工作目录并导航到新目录。例如：<codeblock>gpadmin@gpmaster$ mkdir gppc_work
gpadmin@gpmaster$ cd gppc_work</codeblock></li>
        <li>通过在您选择的编辑器中打开文件，为GPPC源代码准备文件。
          例如，要使用<codeph>vi</codeph>打开名为<codeph>gppc_concat.c</codeph>的文件：
          <codeblock>gpadmin@gpmaster$ vi gppc_concat.c</codeblock></li>
        <li>将以下代码复制/粘贴到文件中：<codeblock>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "gppc.h"

// make the function SQL-invokable
GPPC_FUNCTION_INFO(concat_two_strings);

// declare the function
GppcDatum concat_two_strings(GPPC_FUNCTION_ARGS);

GppcDatum
concat_two_strings(GPPC_FUNCTION_ARGS)
{
    // retrieve the text input arguments
    GppcText arg0 = GPPC_GETARG_TEXT(0);
    GppcText arg1 = GPPC_GETARG_TEXT(1);

    // determine the size of the concatenated string and allocate
    // text memory of this size
    size_t arg0_len = GppcGetTextLength(arg0);
    size_t arg1_len = GppcGetTextLength(arg1);
    GppcText retstring = GppcAllocText(arg0_len + arg1_len);

    // construct the concatenated return string
    memcpy(GppcGetTextPointer(retstring), GppcGetTextPointer(arg0), arg0_len);
    memcpy(GppcGetTextPointer(retstring) + arg0_len, GppcGetTextPointer(arg1), arg1_len);

    GPPC_RETURN_TEXT( retstring );
}</codeblock><p>代码声明并实现了<codeph>concat_two_strings()</codeph>函数。
          它使用GPPC数据类型，宏和函数来获取函数参数，
          为连接的字符串分配内存，将参数复制到新字符串中，然后返回结果。
          </p></li>
        <li>保存文件并退出编辑器。</li>
        <li>在您选择的编辑器中打开名为<codeph>Makefile</codeph>的文件。
          将以下文本复制/粘贴到文件中：
          <codeblock>MODULE_big = gppc_concat
OBJS = gppc_concat.o

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)

PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)
SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir) -lgppc
include $(PGXS)</codeblock></li>
        <li>保存文件并退出编辑器。</li>
        <li>为<codeph>concat_two_strings()</codeph>函数构建GPPC共享库。例如：<codeblock>gpadmin@gpmaster$ make all</codeblock>
          <p><codeph>make</codeph>命令在当前工作目录中生成名为<codeph>gppc_concat.so</codeph>的共享库文件。</p>
          </li>
        <li>将共享库复制到Greenplum数据库安装。
          您必须具有Greenplum数据库管理权限才能复制该文件。
          例如：
          <codeblock>gpadmin@gpmaster$ cp gppc_concat.so /usr/local/greenplum-db/lib/postgresql/</codeblock></li>
        <li>将共享库复制到Greenplum数据库安装中的每个主机。
          例如，如果<codeph>seghostfile</codeph>包含Greenplum数据库集群中segment主机的列表，每个主机行：
          <codeblock>gpadmin@gpmaster$ gpscp -v -f seghostfile /usr/local/greenplum-db/lib/postgresql/gppc_concat.so =:/usr/local/greenplum-db/lib/postgresql/gppc_concat.so</codeblock></li>
        <li>打开<codeph>psql</codeph>会话。例如：
          <codeblock>gpadmin@gpmaster$ psql -d testdb</codeblock></li>
        <li>使用Greenplum数据库注册名为<codeph>concat_two_strings()</codeph>的GPPC函数。
          例如，将Greenplum数据库函数<codeph>concat_with_gppc()</codeph>映射到GPPC <codeph>concat_two_strings()</codeph>函数：
          <codeblock>testdb=# CREATE FUNCTION concat_with_gppc(text, text) RETURNS text
  AS 'gppc_concat', 'concat_two_strings'
LANGUAGE C STRICT;</codeblock></li>
        <li>运行<codeph>concat_with_gppc()</codeph>函数。例如：
          <codeblock>testdb=# SELECT concat_with_gppc( 'happy', 'monday' );
 concat_with_gppc
------------------
 happymonday
(1 row)
</codeblock></li>
      </ol>
    </body>
  </topic>
  <topic id="topic_example_srf" xml:lang="en">
    <title id="py217167">GPPC Set-Returning函数示例</title>
    <body>
      <p>在此示例中，您将开发，构建和部署GPPC共享库。
        您还可以为名为<codeph>return_tbl()</codeph>的GPPC函数创建并运行<codeph>.sql</codeph>注册脚本。
        此函数使用GPPC API获取带有整数和文本列的输入表，确定整数列是否大于13，
        并返回带有输入整数列的结果表和一个标识整数是否为的整数的布尔列<codeph>return_tbl()</codeph>使用GPPC API报告和SRF函数和宏。
        </p>
      <p>您将在Greenplum数据库master主机上开发GPPC函数。
        部署您在此示例中创建的GPPC共享库需要对Greenplum数据库集群的管理访问权限。
        </p>
      <p>执行以下过程以运行该示例：</p><ol>
        <li>登录Greenplum数据库master主机并设置您的环境。例如：<codeblock>$ ssh gpadmin@&lt;gpmaster&gt;
gpadmin@gpmaster$ . /usr/local/greenplum-db/greenplum_path.sh</codeblock></li>
        <li>创建工作目录并导航到新目录。例如：<codeblock>gpadmin@gpmaster$ mkdir gppc_work
gpadmin@gpmaster$ cd gppc_work</codeblock></li>
        <li>通过在您选择的编辑器中打开文件，为GPPC代码准备源文件。
          例如，要使用<codeph>vi</codeph>打开名为<codeph>gppc_concat.c</codeph>的文件：
          <codeblock>gpadmin@gpmaster$ vi gppc_rettbl.c</codeblock></li>
        <li>将以下代码复制/粘贴到文件中：<codeblock>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include "gppc.h"

// initialize the logging level
GppcReportLevel level = GPPC_INFO;

// make the function SQL-invokable and declare the function
GPPC_FUNCTION_INFO(return_tbl);
GppcDatum return_tbl(GPPC_FUNCTION_ARGS);

GppcDatum
return_tbl(GPPC_FUNCTION_ARGS)
{
    GppcFuncCallContext	fctx;
    GppcAnyTable	intbl;
    GppcHeapTuple	intuple;
    GppcTupleDesc	in_tupdesc, out_tupdesc;
    GppcBool  		resbool = false;
    GppcDatum  		result, boolres, values[2];
    bool		nulls[2] = {false, false};

    // single input argument - the table
    intbl = GPPC_GETARG_ANYTABLE(0);

    // set the function context
    if (GPPC_SRF_IS_FIRSTCALL()) {
        fctx = GPPC_SRF_FIRSTCALL_INIT();
    }
    fctx = GPPC_SRF_PERCALL_SETUP();

    // get the tuple descriptor for the input table
    in_tupdesc  = GppcAnyTableGetTupleDesc(intbl);

    // retrieve the next tuple
    intuple = GppcAnyTableGetNextTuple(intbl);
    if( intuple == NULL ) {
      // no more tuples, conclude
      GPPC_SRF_RETURN_DONE(fctx);
    }

    // get the output tuple descriptor and verify that it is
    // defined as we expect
    out_tupdesc = GPPC_SRF_RESULT_DESC();
    if (GppcTupleDescNattrs(out_tupdesc) != 2                ||
        GppcTupleDescAttrType(out_tupdesc, 0) != GppcOidInt4 ||
        GppcTupleDescAttrType(out_tupdesc, 1) != GppcOidBool) {
        GppcReport(GPPC_ERROR, "INVALID out_tupdesc tuple");
    }

    // log the attribute names of the output tuple descriptor
    GppcReport(level, "output tuple descriptor attr0 name: %s", GppcTupleDescAttrName(out_tupdesc, 0));
    GppcReport(level, "output tuple descriptor attr1 name: %s", GppcTupleDescAttrName(out_tupdesc, 1));

    // retrieve the attribute values by name from the tuple
    bool text_isnull, int_isnull;
    GppcDatum intdat = GppcGetAttributeByName(intuple, "id", &amp;int_isnull);
    GppcDatum textdat = GppcGetAttributeByName(intuple, "msg", &amp;text_isnull);

    // convert datum to specific type
    GppcInt4 intarg = GppcDatumGetInt4(intdat);
    GppcReport(level, "id: %d", intarg);
    GppcReport(level, "msg: %s", GppcTextGetCString(GppcDatumGetText(textdat)));

    // perform the >13 check on the integer
    if( !int_isnull &amp;&amp; (intarg > 13) ) {
        // greater than 13?
        resbool = true;
        GppcReport(level, "id is greater than 13!");
    }

    // values are datums; use integer from the tuple and
    // construct the datum for the boolean return
    values[0] = intdat;
    boolres = GppcBoolGetDatum(resbool);
    values[1] = boolres;

    // build a datum tuple and return
    result = GppcBuildHeapTupleDatum(out_tupdesc, values, nulls);
    GPPC_SRF_RETURN_NEXT(fctx, result);

}</codeblock><p>代码声明并实现了<codeph>return_tbl()</codeph>函数。
          它使用GPPC数据类型，宏和函数来获取函数参数，检查元组描述符，构建返回元组，并返回结果。
          该函数还使用SRF宏来跟踪函数调用之间的元组上下文。
          </p></li>
        <li>保存文件并退出编辑器。</li>
        <li>在您选择的编辑器中打开名为<codeph>Makefile</codeph>的文件。
          将以下文本复制/粘贴到文件中：
          <codeblock>MODULE_big = gppc_rettbl
OBJS = gppc_rettbl.o

PG_CONFIG = pg_config
PGXS := $(shell $(PG_CONFIG) --pgxs)

PG_CPPFLAGS = -I$(shell $(PG_CONFIG) --includedir)
SHLIB_LINK = -L$(shell $(PG_CONFIG) --libdir) -lgppc
include $(PGXS)</codeblock></li>
        <li>保存文件并退出编辑器。</li>
        <li>为<codeph>return_tbl()</codeph>函数构建GPPC共享库。例如：<codeblock>gpadmin@gpmaster$ make all</codeblock>
          <p><codeph>make</codeph>命令在当前工作目录中生成名为<codeph>gppc_rettbl.so</codeph>的共享库文件。</p></li>
        <li>将共享库复制到Greenplum数据库安装。
          您必须具有Greenplum数据库管理权限才能复制该文件。
          例如：
          <codeblock>gpadmin@gpmaster$ cp gppc_rettbl.so /usr/local/greenplum-db/lib/postgresql/</codeblock>
          <p>此命令将共享库复制到<codeph>$libdir</codeph></p></li>
        <li>将共享库复制到Greenplum数据库安装中的每个主机。
          例如，如果<codeph>seghostfile</codeph>包含Greenplum数据库集群中segment主机的列表，每个主机一行：
          <codeblock>gpadmin@gpmaster$ gpscp -v -f seghostfile /usr/local/greenplum-db/lib/postgresql/gppc_rettbl.so =:/usr/local/greenplum-db/lib/postgresql/gppc_rettbl.so</codeblock></li>
        <li>创建<codeph>.sql</codeph>文件以注册GPPC <codeph>return_tbl()</codeph>函数。
          在您选择的编辑器中打开名为<codeph>gppc_rettbl_reg.sql</codeph>的文件。
          </li>
        <li>将以下文本复制/粘贴到文件中：<codeblock>CREATE FUNCTION rettbl_gppc(anytable) RETURNS TABLE(id int4, thirteen bool)
  AS 'gppc_rettbl', 'return_tbl'
LANGUAGE C STRICT;</codeblock></li>
        <li>通过运行刚刚创建的脚本来注册GPPC功能。
          例如，要在名为<codeph>testdb</codeph>的数据库中注册该函数：
          <codeblock>gpadmin@gpmaster$ psql -d testdb -f gppc_rettbl_reg.sql</codeblock></li>
        <li>打开<codeph>psql</codeph>会话。例如：<codeblock>gpadmin@gpmaster$ psql -d testdb</codeblock></li>
        <li>创建包含一些测试数据的表。例如：<codeblock>CREATE TABLE gppc_testtbl( id int, msg text );
INSERT INTO gppc_testtbl VALUES (1, 'f1');
INSERT INTO gppc_testtbl VALUES (7, 'f7');
INSERT INTO gppc_testtbl VALUES (10, 'f10');
INSERT INTO gppc_testtbl VALUES (13, 'f13');
INSERT INTO gppc_testtbl VALUES (15, 'f15');
INSERT INTO gppc_testtbl VALUES (17, 'f17');</codeblock></li>
        <li>运行<codeph>rettbl_gppc()</codeph>函数。例如：<codeblock>testdb=# SELECT * FROM rettbl_gppc(TABLE(SELECT * FROM gppc_testtbl));
 id | thirteen 
----+----------
  1 | f
  7 | f
 13 | f
 15 | t
 17 | t
 10 | f
(6 rows)
</codeblock></li>
      </ol>
    </body>
  </topic>
</topic>
